<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zgjjj的博客</title>
  
  <subtitle>你仍然是我的光芒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zgjjj.github.io/"/>
  <updated>2019-03-26T08:20:55.626Z</updated>
  <id>http://zgjjj.github.io/</id>
  
  <author>
    <name>zgjjj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>概中概 题解</title>
    <link href="http://zgjjj.github.io/2019/03/26/%E6%A6%82%E4%B8%AD%E6%A6%82-%E9%A2%98%E8%A7%A3/"/>
    <id>http://zgjjj.github.io/2019/03/26/概中概-题解/</id>
    <published>2019-03-26T07:58:22.000Z</published>
    <updated>2019-03-26T08:20:55.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>嘤嘤嘤,<a href="https://www.luogu.org/space/show?uid=104841" target="_blank" rel="noopener">zgjjj</a>又荒废whk推一些奇奇怪怪的东西了</p><a id="more"></a><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个随机数生成函数：</p><p>$$rand(x,y)​$$</p><p><strong>等概率</strong>返回区间$[x,y]​$中的一个整数值。</p><p>给定函数$f(x) = rand(x,f(x + k))​$</p><p>zgjjj想知道$f(1)​$的期望值</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行，一个整数T$(T\le 20000)$,表示数据组数</p><p>下面的T+1行，每行一个整数k，含义见题目描述</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>共T行，每行一个<strong>既约分数或整数</strong>，为所求期望。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>对于30%的数据，$k\le 3$</p><p>对于60%的数据，$k\le 20$</p><p>对于100%的数据，保证结果的<strong>分子与分母</strong>均在int数据范围内</p><p>请务必化简分数!</p><p>分数的输出格式为： <code>1/2</code></p><h1 id="思想及推导过程"><a href="#思想及推导过程" class="headerlink" title="思想及推导过程"></a>思想及推导过程</h1><p>看啥，写你的题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;嘤嘤嘤,&lt;a href=&quot;https://www.luogu.org/space/show?uid=104841&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zgjjj&lt;/a&gt;又荒废whk推一些奇奇怪怪的东西了&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://zgjjj.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="数学" scheme="http://zgjjj.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="概率期望" scheme="http://zgjjj.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P1073 最优贸易 解题报告</title>
    <link href="http://zgjjj.github.io/2019/03/21/Luogu-P1073-%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>http://zgjjj.github.io/2019/03/21/Luogu-P1073-最优贸易-解题报告/</id>
    <published>2019-03-21T08:20:26.000Z</published>
    <updated>2019-03-21T08:33:10.389Z</updated>
    
    <content type="html"><![CDATA[<p>发一个<del>自认为代码比较好看的</del>双向SPFA</p><a id="more"></a><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.org/problemnew/show/P1073" target="_blank" rel="noopener">题目链接</a></h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先正图跑一遍SPFA维护每个点对于采购价的最小值。</p><p>在数据读入时存反图，以$s$点为源点，再次跑一遍SPFA维护每个点对于卖出价的最小值。</p><p>根据题意描述，在存图的时候要注意判断是否为无向边。</p><p>要注意本题是点权而不是边权。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e5</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head1[N], next1[M], ver1[M];</span><br><span class="line"><span class="keyword">int</span> head2[N], next2[M], ver2[M];</span><br><span class="line"><span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> d1[N], v1[N], d2[N], v2[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ver1[++cnt1] = y, next1[cnt1] = head1[x], head1[x] = cnt1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">ver2[++cnt2] = y, next2[cnt2] = head2[x], head2[x] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最小值 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line"><span class="built_in">memset</span>(v1,<span class="number">0</span>,<span class="keyword">sizeof</span>(v1));</span><br><span class="line"><span class="built_in">memset</span>(d1,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(d1));</span><br><span class="line">v1[<span class="number">1</span>] = <span class="number">1</span>, d1[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">q1.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(!q1.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q1.front();</span><br><span class="line">q1.pop();</span><br><span class="line">v1[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = head1[x] ; i ; i = next1[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = ver1[i];</span><br><span class="line"><span class="keyword">if</span>(d1[y] &gt; min(d1[x], a[y])) &#123;</span><br><span class="line">d1[y] = min(d1[x], a[y]);</span><br><span class="line"><span class="keyword">if</span>(!v1[y]) q1.push(y), v1[y] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line"><span class="built_in">memset</span>(v2,<span class="number">0</span>,<span class="keyword">sizeof</span>(v2));</span><br><span class="line"><span class="built_in">memset</span>(d2,<span class="number">0</span>,<span class="keyword">sizeof</span>(d2));</span><br><span class="line">v2[n] = <span class="number">1</span>, d2[n] = a[n];</span><br><span class="line">q2.push(n);</span><br><span class="line"><span class="keyword">while</span>(!q2.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = q2.front();</span><br><span class="line">q2.pop();</span><br><span class="line">v2[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = head2[x] ; i ; i = next2[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = ver2[i];</span><br><span class="line"><span class="keyword">if</span>(d2[y] &lt; max(d2[x], a[y])) &#123;</span><br><span class="line">d2[y] = max(d2[x], a[y]);</span><br><span class="line"><span class="keyword">if</span>(!v2[y]) q2.push(y), v2[y] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y, opt;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;opt);</span><br><span class="line"><span class="keyword">if</span>(opt == <span class="number">1</span>) &#123;</span><br><span class="line">add1(x,y);</span><br><span class="line">add2(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt == <span class="number">2</span>) &#123;</span><br><span class="line">add1(x,y);</span><br><span class="line">add1(y,x);</span><br><span class="line">add2(x,y);</span><br><span class="line">add2(y,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">spfa1();</span><br><span class="line">spfa2();</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">ans = max(ans,d2[i] - d1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发一个&lt;del&gt;自认为代码比较好看的&lt;/del&gt;双向SPFA&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="http://zgjjj.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="SPFA" scheme="http://zgjjj.github.io/tags/SPFA/"/>
    
  </entry>
  
  <entry>
    <title>HBTSC 2019 爆零记</title>
    <link href="http://zgjjj.github.io/2019/03/14/HBTSC-2018-%E7%88%86%E9%9B%B6%E8%AE%B0/"/>
    <id>http://zgjjj.github.io/2019/03/14/HBTSC-2018-爆零记/</id>
    <published>2019-03-14T09:38:43.000Z</published>
    <updated>2019-03-16T11:10:44.442Z</updated>
    
    <content type="html"><![CDATA[<p>占坑，稳坐rk inf。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;占坑，稳坐rk inf。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="游记" scheme="http://zgjjj.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P4316 绿豆蛙的归宿 解题报告</title>
    <link href="http://zgjjj.github.io/2019/03/14/%E7%BB%BF%E8%B1%86%E8%9B%99%E7%9A%84%E5%BD%92%E5%AE%BF/"/>
    <id>http://zgjjj.github.io/2019/03/14/绿豆蛙的归宿/</id>
    <published>2019-03-14T08:50:54.000Z</published>
    <updated>2019-03-14T09:27:43.004Z</updated>
    
    <content type="html"><![CDATA[<p><del>手感太差了手写队列都能出锅</del></p><a id="more"></a><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.org/problemnew/show/P4316" target="_blank" rel="noopener">题目链接</a></h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>随着新版百度空间的上线，Blog宠物绿豆蛙完成了它的使命，去寻找它新的归宿。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个有向无环图，起点为$1$终点为$N$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果有$K$条离开该点的道路，绿豆蛙可以选择任意一条道路离开该点，并且走向每条路的概率为 $1/K$ 。 现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度<strong>期望</strong>是多少？</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行: 两个整数 N M，代表图中有N个点、M条边<br>第二行到第 1+M 行: 每行3个整数 a b c，代表从a到b有一条长度为c的有向边</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>从起点到终点路径总长度的期望值，四舍五入保留两位小数。</p><h3 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h3><h4 id="输入样例-1："><a href="#输入样例-1：" class="headerlink" title="输入样例#1："></a>输入样例#1：</h4><blockquote><p>4 4<br>1 2 1<br>1 3 2<br>2 3 3<br>3 4 4</p></blockquote><h4 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h4><blockquote><p>7.00</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>对于20%的数据 N&lt;=100</p><p>对于40%的数据 N&lt;=1000</p><p>对于60%的数据 N&lt;=10000</p><p>对于100%的数据 N&lt;=100000，M&lt;=2*N</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>算是<strong>概率期望DP</strong>比较简单的一道了。</p><p>考虑<strong>目标状态</strong>：从起点走到终点的所经过的路径总长度期望。</p><p>可以使用数组<code>DP[i]</code>来表示点$i$到终点所经路径的总长度期望。</p><p>目标状态即为<code>DP[1]</code>。</p><p>定义点$i$出度为<strong>k</strong>，对于每一个与点$i$联通的顶点$j$，根据期望的定义不难得出<strong>状态转移方程</strong>：<br>$$DP[i] = \frac{1}{k}\sum\limits_{dist_{i,j}\neq INF}(DP[j]+dist_{i,j})$$</p><p>可以在对<strong>DAG拓扑排序</strong>的同时完成状态转移。</p><h1 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h1><p>这道题挺坑的<del>明明是自己太菜了</del></p><p><img src="https://i.loli.net/2019/03/14/5c8a1e7749a30.png" alt="1552554437139"></p><p><img src="https://i.loli.net/2019/03/14/5c8a1e774adbd.png" alt="1552554450942"></p><p>说一说写的过程中犯的一些错误。</p><h2 id="关于存图"><a href="#关于存图" class="headerlink" title="关于存图"></a>关于存图</h2><p>因为从终点状态确定，所以需要从终点往起点转移。对应地，图也应该存反图。</p><p><del>我一直以为反图只能跑多源一汇Dijkstra想不到还有这用处</del></p><h2 id="关于邻接表"><a href="#关于邻接表" class="headerlink" title="关于邻接表"></a>关于邻接表</h2><p>自己写的时候又犯了初学时的错误…</p><p>四个数组大小都是醒目的<code>N</code>（<code>head[]</code>大小确实是$N$</p><p>然后就一直70pts…</p><p>评测居然报的不是<code>RE</code></p><h2 id="关于队列"><a href="#关于队列" class="headerlink" title="关于队列"></a>关于队列</h2><p>第一次交题的时候看到有一个点T了，就换了手写队列，加了快读。</p><p>然而我已经几百年没碰手写队列了…</p><p>先把代码放着：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> head, tail;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;head = tail = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> head &gt; tail;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;q[++tail] = x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;head++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> q[head];&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一遍写的时候，把<code>empty()</code>里面的<code>&gt;</code>写成了<code>-</code></p><p>这样的话，当<code>head&lt;tail</code>时，返回值应该是<code>false</code>，但原写法却返回了<code>true</code>。</p><h2 id="关于Top-Sort"><a href="#关于Top-Sort" class="headerlink" title="关于Top Sort"></a>关于Top Sort</h2><p>需要开两个数组来保存节点的度，然后<strong>Top Sort</strong>的时候仅对一个做出更改。</p><p>不然要么你拓扑排序会炸，要么你算的期望会炸。</p><h2 id="关于前向星遍历"><a href="#关于前向星遍历" class="headerlink" title="关于前向星遍历"></a>关于前向星遍历</h2><p><del>没什么好说的，我太菜了才能把<code>i = next[i]</code>打成<code>i++</code></del></p><p>细节差不多就这些。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span> , w = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) w = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;r = r * <span class="number">10</span> + ch - <span class="string">'0'</span>, ch = getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> r * w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) write(x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read() FastIO::read()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write(x) FastIO::write(x)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> head, tail;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;head = tail = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> head &gt; tail;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;q[++tail] = x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;head++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> q[head];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> edge[M] , ver[M] , next[M] , head[N] , cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> out[N] , deg[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">double</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">edge[++cnt] = z, ver[cnt] = y, next[cnt] = head[x], head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = read() , m = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m ; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = read(), y = read(), z = read();</span><br><span class="line">Add(y, x, z);</span><br><span class="line">out[x]++; deg[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span> q;</span><br><span class="line">q.init();</span><br><span class="line">q.push(n);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> now = q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = head[now] ; i ; i = next[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> to = ver[i];</span><br><span class="line">dp[to] += (dp[now] + edge[i]) / out[to];</span><br><span class="line">deg[to]--;</span><br><span class="line"><span class="keyword">if</span>(deg[to] == <span class="number">0</span>) q.push(to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f"</span>,dp[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>吐槽一下luogu的玄学评测，应该RE的问题，吸氧TLE，不吸氧WA。太真实了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;手感太差了手写队列都能出锅&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="解题报告" scheme="http://zgjjj.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="概率期望DP" scheme="http://zgjjj.github.io/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9BDP/"/>
    
      <category term="动态规划" scheme="http://zgjjj.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>多项式 学习报告</title>
    <link href="http://zgjjj.github.io/2019/03/07/%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://zgjjj.github.io/2019/03/07/多项式-学习报告/</id>
    <published>2019-03-07T09:51:02.000Z</published>
    <updated>2019-03-09T10:40:21.204Z</updated>
    
    <content type="html"><![CDATA[<p>看<del>过期的</del><strong>luogu网课</strong>学<del>会</del>了多项式</p><a id="more"></a><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>由<strong>常数</strong>及<strong>未知数</strong>通过<strong>有限次乘法、加法以及自然数幂次乘方</strong>的组合，得到的代数表达式。</p><p>本文仅讨论<strong>单元</strong>多项式。</p><h3 id="简记"><a href="#简记" class="headerlink" title="简记"></a>简记</h3><p>记$f(x) = \sum\limits_{i=0}^{n-1}a_ix^i$为一个<strong>n-1次多项式</strong>。</p><p>其中<strong>该多项式的次数</strong>为<strong>n-1</strong>，记为${\deg\;f = n-1}$。</p><p>对于该多项式<strong>次数为i</strong>的一项，我们记$f(x)[i]$为<strong>该项的系数</strong>${a_i}$，简写为$f[i]$。</p><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>设$f(x)=\sum\limits_{i=0}^{n-1}{a_ix^i},g(x)=\sum\limits_{i=0}^{n-1}b_ix^i$</p><h4 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h4><p>$$(f+g)(x)=\sum\limits_{i=0}^{n-1}(a_i+b_i)\times x^i$$</p><p>$$(f-g)(x)=\sum\limits_{i=0}^{n-1}(a_i-b_i)\times x^i$$</p><h4 id="卷积（多项式乘法）"><a href="#卷积（多项式乘法）" class="headerlink" title="卷积（多项式乘法）"></a>卷积（多项式乘法）</h4><p>$$(f\times g)(x)=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}a_i b_j \times x^{i+j}$$</p><p>这个操作是$O(n^2)$的。</p><h5 id="循环卷积"><a href="#循环卷积" class="headerlink" title="循环卷积"></a>循环卷积</h5><p>$$(f \times g)(x) = \sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}a_ib_j\times x ^{[(i+j)(\mod n)]} $$</p><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><blockquote><p>代数基本定理：任何一元n次方程在复数域内都恰好有n个解</p></blockquote><h3 id="虚数单位"><a href="#虚数单位" class="headerlink" title="虚数单位"></a>虚数单位</h3><p>定义$i=\sqrt{-1}$，其中$i$被称为<strong>虚数单位</strong>。</p><h3 id="复数-1"><a href="#复数-1" class="headerlink" title="复数"></a>复数</h3><p><strong>复数集合</strong>符号为$\mathbb{C}$，$\mathbb{C}= \{ a+bi \mid a,b\in\mathbb R \} $</p><p>对于一个复数$z=a+bi$:</p><p>$a$被称为$z$的<strong>实部</strong>，记为$\mathbf {Re(z)}$</p><p>$b$被称为$z$的<strong>虚部</strong>，记为$\mathbf{lm(z)}$</p><h3 id="算术运算-1"><a href="#算术运算-1" class="headerlink" title="算术运算"></a>算术运算</h3><p>记$z_0,z_1\in\mathbb C,z_0=a_0+b_0i,z_1=a_1+b_1i$</p><h4 id="加减法-1"><a href="#加减法-1" class="headerlink" title="加减法"></a>加减法</h4><p>$$z_0\pm z_1=(a_0\pm a_1)+(b_0 \pm b_1)i$$</p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>$$z_0\times z_1 = (a_0a_1-b_0b_1)+(a_0b_1+a_1b_0)i$$</p><p>可以将复数当成一个<strong>一次二项式</strong>来理解上面的式子。</p><h3 id="复平面"><a href="#复平面" class="headerlink" title="复平面"></a>复平面</h3><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=72d5ec35c8cec3fd8f3ea077e68ad4b6/f636afc379310a5578decf0dbc4543a983261054.jpg" alt="图1.复数平面"></p><p>复数$z=x+yi$与复平面上$(x,y)$一一对应。</p><p>$\varphi$为<strong>幅角</strong>，那么可以得到复数的<strong>三角表示</strong>：</p><p>$$z=r\times (\cos \varphi+i\sin \varphi)$$</p><h4 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h4><p>$$e^{i\varphi}=\cos \varphi + i\sin \varphi$$</p><h3 id="模长"><a href="#模长" class="headerlink" title="模长"></a>模长</h3><p>表示复平面内向量${\vec z}$的模长，记为$\left|{z}\right|$</p><p>$$\left|z\right|=\sqrt{a^2+b^2}$$</p><h3 id="共轭"><a href="#共轭" class="headerlink" title="共轭"></a>共轭</h3><p>表示复平面内与$z$关于<strong>x轴</strong>对称的点，记为$\bar z$</p><p>$$\overline z=a-bi$$</p><p>不难得到:</p><p>$$\overline zz=\left|z\right|^2$$</p><p><strong>共轭复数的四则运算都可以提取</strong></p><p>$$\overline{z_0\pm z_1}=\overline{z_0}\pm\overline{z_1}$$</p><p>$$\lambda z=\lambda a+\lambda bi$$</p><p>$$\overline{z_0\times z_1}=\overline{z_0}\times \overline{z_1}$$</p><p>$$\frac{z_0}{z_1}=\frac{z_0\times \overline {z_1}}{\left|z_1\right|^2}$$</p><h3 id="三角表示的复数乘法"><a href="#三角表示的复数乘法" class="headerlink" title="三角表示的复数乘法"></a>三角表示的复数乘法</h3><blockquote><p>此部分内容来自课件</p></blockquote><p>回顾复数乘法公式$$z_0 \times z_1 = (a_0a_1 + b_0b_1) + (a_0b_1 + a_1b_0) i$$，我们可以注意到<br>$$\mathbf{Re}(z_0 \times z_1) = r_0 \cos\varphi_0 \times r_1 \cos\varphi_1-r_0 \sin\varphi_0 \times r_1 \sin\varphi_1 = r_0r_1 \times \cos(\varphi_0 +\varphi_1)$$，<br>同时又有$$\mathbf{Im}(z_0 \times z_1) = r_0r_1 \times \sin (\varphi_0 + \varphi_1) $$。</p><p>尝试用三角表示改写乘法:</p><p>$$(r_0 \times e^{i\varphi_0} ) \times (r_1 \times e^{i\varphi_1} ) = (r_0 \times r_1) \times e^{i(\varphi_0+\varphi_1)}$$</p><h4 id="棣莫弗定理"><a href="#棣莫弗定理" class="headerlink" title="棣莫弗定理"></a>棣莫弗定理</h4><p>$$z_0z_1 = r_0r_1 \times(cos(φ_0 + φ_1) + i \sin(φ_0 + φ_1))$$</p><p>即两复数相乘的结果，模长为两者之积，幅角为二者之和。</p><p><strong>棣莫弗公式</strong>：</p><p>$$z^n = r^n \times (\cos(n\varphi) + i\sin(n\varphi))$$</p><h3 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h3><p>满足方程$x^n = 1 $的所有的解，称为$n$次单位根。<br>根据<strong>代数基本定理</strong>，$n$次方程在复数域内有$n$个解。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设$x=r\times (\cos \varphi+i\sin \varphi )$，若$x$是$n$次单位根，则：</p><p>$\begin{cases}r^n=1\\\cos (n\varphi)=1\\\sin(n\varphi)=0\end{cases}$</p><p><strong>推导过程</strong>：<br>$\qquad x^n=1$</p><p>$\Rightarrow(r\times (\cos \varphi+i\sin \varphi ))^n=1$</p><p>$\Rightarrow(r^n\times (\cos n\varphi+i\sin n\varphi))=1$</p><p>$\Rightarrow \sin n\varphi = 1$</p><p>$\Rightarrow \varphi=0$</p><p>$\Rightarrow \cos n\varphi = 1 $</p><p>$\Rightarrow r^n=1$</p><p>$\Rightarrow r= 1$</p><p>那么，$r=1,\varphi=\frac{2\pi+k}{n}​$$k\in[0,n-1]\&amp; k\in\mathbb Z​$恰好是$x^n=1​$的$n​$个不同的解。</p><h4 id="结合单位圆"><a href="#结合单位圆" class="headerlink" title="结合单位圆"></a>结合单位圆</h4><p><img src="https://i.loli.net/2019/03/09/5c836112517bd.png" alt=""></p><p>很容易得到$n$个单位根分别为$e^{\frac{2k\pi }{n}i}$，$k\in[1,n-1]\&amp;k\in\mathbb Z$</p><p>记单位圆根$\mathbf \omega_n=e^{\frac{\omega\pi}{n}i}$,则$n$个单位根又可以写成${\mathbf \omega_n^k},k\in[1,n-1]\&amp; k\in\mathbb Z$</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>$\mathbf \omega_n^m=\mathbf \omega_{n/k}^{m/k}​$</li><li>$\mathbf \omega_n^2=\mathbf \omega_{n/2}​$</li><li>$\mathbf \omega_n^j=- \mathbf \omega_n^{j+n/2}​$</li><li>$\sum\limits_{k=0}^{n-1}\mathbf \omega_n^{kt}={\begin{cases} n,n\mid t\\0,n\nmid t \end{cases}}​$(可通过等比数列求和证明)</li><li>$[n\mid t]=\frac{1}{n}\sum\limits_{j=0}^{n-1}\mathbf \omega_n^{tj}​$(该性质是<strong>FFT</strong>的关键)</li></ol><blockquote><p><strong>性质5</strong>中，<strong>[条件判断句1]</strong>运算符返回值为<code>true</code>当且仅当条件判断句1为<strong>真</strong>。</p></blockquote><h1 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h1><blockquote><p>快速傅里叶变换(<strong>F</strong>ast <strong>F</strong>ourier <strong>T</strong>ransform),即利用计算机计算<strong>离散傅里叶变换(DFT)</strong>的高效、快速计算方法的统称，简称<strong>FFT</strong>。快速傅里叶变换是1965年由<strong>J.W.库利</strong>和<strong>T.W.图基</strong>提出的。采用这种<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025" target="_blank" rel="noopener">算法</a>能使计算机计算<a href="https://baike.baidu.com/item/%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/6379901" target="_blank" rel="noopener">离散傅里叶变换</a>所需要的<a href="https://baike.baidu.com/item/%E4%B9%98%E6%B3%95/11036001" target="_blank" rel="noopener">乘法</a>次数大为减少，特别是被变换的抽样点数N越多，FFT算法计算量的节省就越显著。</p><blockquote><p> 来源：<a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/214957?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p></blockquote></blockquote><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>记 $\deg\;f = \deg \; g = n - 1 ​$，$f​$与$g​$的<strong>循环卷积</strong>为$h​$</p><p>$\qquad h[z]​$</p><p>$\quad =\sum\limits_{x=0}^{n-1} \sum\limits_{y=0}^{n-1}f[x]\times g[y]\times [n\mid x+y-z]​$</p><p>$\quad =\sum\limits_{x=0}^{n-1} \sum\limits_{y=0}^{n-1}f[x]\times g[y]\times \frac{1}{n}\sum\limits_{t=0}^{n-1}\omega_n^{t(x+y-z)}​$</p><p>$\quad = \frac{1}{n}\sum\limits_{t=0}^{n-1}\omega_n^{-tz}(\sum\limits_{x=0}^{n-1}{f[x]\times \omega_n^{tx}})(\sum\limits_{y=0}^{n-1}g[y]\times \omega_n^{ty})​$</p><p>设$F[t] = \sum\limits _{x=0} ^{n-1} f[x]\times \omega_n^{tx},G[t] = \sum\limits_{y=0}^{n-1}g[x]\times \omega_n^{ty},H[t] = F[t]\times G[t]$</p><p>那么$h[t] = \frac{1}{n}\sum\limits_{x=0}^{n-1}H[x]\times \omega_n^{-tx}​$</p><p>由$f,g$计算$F,G$的过程被称为<strong>离散傅里叶变换</strong>(<strong>D</strong>iscrete <strong>F</strong>ourier <strong>T</strong>ransform)</p><p>由$H计算h$的过程被称为<strong>离散傅里叶逆变换</strong>(<strong>I</strong>nverse <strong>D</strong>iscrete <strong>F</strong>ourier <strong>T</strong>ransform)</p><p>两者过程相差无几。</p><h2 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h2><p>现在仅考虑$n​$为<strong>偶数</strong>的情况。</p><p>给定$f​$，计算$F[t] = \sum\limits_{x=0}^{n-1}f[x] \times \omega _n^{tx}​$。</p><p>设$f_a=f[2k],f_b=f[2k+1],k\in\mathbb N​$</p><p>$$\therefore F_a[t] = \sum\limits_{a=0}^{n/2-1}f_a[a]\times \omega _{n/2}^{ta}​$$</p><p>$$\therefore F_b[t] = \sum \limits_{b=0}^{ n/2-1}f_b[b]\times \omega_{n/2}^{tb}​$$</p><ul><li>当$j&lt;n/2时$</li></ul><p>$\therefore F[j] = \sum\limits_{a=0}^{n/2-1}\omega_n^{2a\times j}f[2a]+\sum\limits_{b=0}^{n/2-1}\omega_n^{(2b+1)\times j}f[2b+1]​$</p><p>$\quad \quad\quad =\sum\limits_{a=0}^{n/2-1}\omega_{n/2}^{a\times j}f_a[a]+\omega_{n}^j \times \sum\limits_{b=0}^{n/2-1}\omega _{n/2}^{b\times j}f_b[b]​$</p><p>$\quad \quad \quad =F_a[j]+\omega_n^jF_b[j]​$</p><ul><li>当$j\geqslant n/2$时</li></ul><p>$\therefore F[j+n/2]=\sum\limits_{a=0}^{n/2-1}\omega_n^{2a\times (j+n/2)}f[2a]+\sum\limits_{b=0}^{n/2-1}\omega_n^{(2b+1)\times (j+n/2)}f[2b+1]​$</p><p>$\quad \quad \quad \quad \quad   =\sum\limits_{a=0}^{n/2-1}\omega_{n/2}^{a}f_a[a]+\omega_n^{j+n/2}\times \sum\limits_{b=0}^{n/2-1}\omega_{n/2}^{b}f_b[b]$</p><p>$\quad \quad \quad \quad \quad   =F_a[j]+\omega_n^{j+n/2}F_b[j]​$</p><p>$\quad \quad \quad \quad \quad   =F_a[j]-\omega_n^jF_b[j]​$</p><p>计算出$F_a$与$F_b$后，可以$O(n)$得到$F$,而$F_a,F_b$的计算都是项数为$n/2$的DFT，我们仅需递归求解规模为原问题规模一半的子问题。</p><p>边界情况：<code>n=1</code>。</p><p>由<strong>主定理</strong>：<strong>DFT</strong>的时间复杂度为$T(n)=2T(n/2)+O(n) =O(n\log n)$</p><h2 id="IDFT"><a href="#IDFT" class="headerlink" title="IDFT"></a>IDFT</h2><p>与<strong>DFT</strong>区别不大，仅需将式中的$\omega_n^{j}$修改为$\omega _n ^{-j}$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看&lt;del&gt;过期的&lt;/del&gt;&lt;strong&gt;luogu网课&lt;/strong&gt;学&lt;del&gt;会&lt;/del&gt;了多项式&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习报告" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    
      <category term="多项式" scheme="http://zgjjj.github.io/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Nim博弈 学习报告</title>
    <link href="http://zgjjj.github.io/2019/03/05/Nim%E5%8D%9A%E5%BC%88-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://zgjjj.github.io/2019/03/05/Nim博弈-学习报告/</id>
    <published>2019-03-05T08:56:50.000Z</published>
    <updated>2019-03-05T09:12:23.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nim取石子游戏"><a href="#Nim取石子游戏" class="headerlink" title="Nim取石子游戏"></a>Nim取石子游戏</h1><p>甲，乙两个人玩Nim取石子游戏。<br>nim游戏的规则是这样的：地上有n堆石子（每堆石子数量小于10000），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这n堆石子的数量，他想知道是否存在先手必胜的策略。</p><a id="more"></a><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Nim博弈先手必胜，当且仅当：<br>$$XOR_{a_1}^{a_n}=0$$</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>（此部分搬运 <a href="https://www.luogu.org/space/show?uid=88804" target="_blank" rel="noopener">y2823774827y</a>的题解，在此对原作者表示敬意）</p><p>用比较通俗的方式讲一下吧： 题目本意是给出n堆石子，轮流在其中一堆去任意个，谁不能去谁就输。</p><p>思路：证明所有石子异或和为0则先手必输</p><p>证明：</p><ol><li><p>反正最终情况就是每堆都为0，先手必输，所以我们考虑怎么把情况转换到这里。</p></li><li><p>如果异或和的最高位为i，则有一堆石子第i为为1（不然怎么会有i位）</p></li><li><p>设A1就为那堆石子，其他堆石子异或和设为x，总异或和设为k，则 A1 xor x=k，把A1变成A1 xor k，那么后手面对的则是（A1 xor k）xor x=0，</p><p>举个例子:11001 xor 11100=101，则有（11001 xor 101）xor 11100=0</p></li><li><p>如果现在的异或和已经为0了（不为最终情况），那么怎么转换异或和都不能为0</p></li><li><p>好，我们根据3 4点得出：如果先手异或和不为0，可以一步让后手的情况为异或和为0；如果先手异或和为0，那么后手异或和就不为0</p></li><li><p>终于开始进行游戏了，如果现在先手面对的情况异或和不为0，则一直让后手异或和为0，最后面对最终情况，后手输，则先手赢；如果先手面对的情况异或和为0，后手则赢</p></li></ol><h1 id="SG函数与ICG游戏"><a href="#SG函数与ICG游戏" class="headerlink" title="SG函数与ICG游戏"></a>SG函数与ICG游戏</h1><p>（占坑，学了再写）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Nim取石子游戏&quot;&gt;&lt;a href=&quot;#Nim取石子游戏&quot; class=&quot;headerlink&quot; title=&quot;Nim取石子游戏&quot;&gt;&lt;/a&gt;Nim取石子游戏&lt;/h1&gt;&lt;p&gt;甲，乙两个人玩Nim取石子游戏。&lt;br&gt;nim游戏的规则是这样的：地上有n堆石子（每堆石子数量小于10000），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这n堆石子的数量，他想知道是否存在先手必胜的策略。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习报告" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    
      <category term="博弈论" scheme="http://zgjjj.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="Nim博弈" scheme="http://zgjjj.github.io/tags/Nim%E5%8D%9A%E5%BC%88/"/>
    
  </entry>
  
  <entry>
    <title>矩阵快速幂 学习报告</title>
    <link href="http://zgjjj.github.io/2019/03/05/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://zgjjj.github.io/2019/03/05/矩阵快速幂-学习报告/</id>
    <published>2019-03-05T08:20:09.000Z</published>
    <updated>2019-03-05T08:55:20.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵的存储"><a href="#矩阵的存储" class="headerlink" title="矩阵的存储"></a>矩阵的存储</h1><p>为方便编写函数，我们使用一个<strong>结构体</strong><code>Mat</code>来存储一个矩阵。</p><p>同时可以构造函数使矩阵元素的初始值为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[N][N];<span class="comment">//N视情况而定</span></span><br><span class="line">    mat()&#123;<span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对于大小为$n\times m​$的矩阵$A​$和大小为$n\times k​$的矩阵$B​$，规定$C=A\times B​$，其中：<br>$$C_{i,j}=\sum\limits_{k=1}^{n}A_{i,p}*B_{p,j}​$$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat a, mat b)</span> </span>&#123;</span><br><span class="line">    mat ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k++) &#123;</span><br><span class="line">                ans.m[i][j] += a.m[i][k] * b.m[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="普通快速幂"><a href="#普通快速幂" class="headerlink" title="普通快速幂"></a>普通快速幂</h1><p>这里只给出实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;<span class="comment">//一定要记住初始值为1</span></span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans * a;</span><br><span class="line">        a*=a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h1><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>常用于<strong>加速递推</strong>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们结合普通快速幂的思想，将元素换为矩阵，不难得到下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mat <span class="title">power</span><span class="params">(mat a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    mat ans;<span class="comment">//这里的ans已经初始化，具体看下文</span></span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = mul(ans, a);</span><br><span class="line">        a = mul(a, a);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="看到代码里的注释了"><a href="#看到代码里的注释了" class="headerlink" title="看到代码里的注释了?"></a>看到代码里的注释了<img src="file:///C:\Users\zgjjj\AppData\Local\Temp\SGPicFaceTpBq\3572\0065A738.png" alt="img">?</h3><p>矩阵$ans$同样是要初始化的，不同于普通快速幂，这里的$ans$应初始化为<strong>单位矩阵</strong>。<del>（不知道是啥的，百度去吧）</del><del>(应该没人不知道吧…)</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">    ans.m[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们往往把它封装在<code>init()</code>里面，因为在数列递推问题中，要初始化的还有$base$矩阵。</p><h1 id="不同的写法"><a href="#不同的写法" class="headerlink" title="不同的写法"></a>不同的写法</h1><p><del>（打<code>mul()</code>太累了？）</del>，我们还可以在结构体内重载<code>*</code><del>和*=</del>运算符。没什么大的区别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[N][N];</span><br><span class="line">    mat()&#123;<span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));&#125;</span><br><span class="line">    mat <span class="keyword">operator</span> * (<span class="keyword">const</span> mat &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        mat ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= n ; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= n ; k++) &#123;</span><br><span class="line">                ans.m[i][j] += m[i][k] * a.m[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，快速幂中的<code>mul()</code>就要换成<code>*</code>。</p><h1 id="关于数列加速递推"><a href="#关于数列加速递推" class="headerlink" title="关于数列加速递推"></a>关于数列加速递推</h1><h2 id="构造矩阵"><a href="#构造矩阵" class="headerlink" title="构造矩阵"></a>构造矩阵</h2><p><del>我讲不来怎么构造</del></p><p>为了使用矩阵快速幂，我们需要构造一个矩阵<code>base</code>，使得每<strong>乘</strong>一次<code>base</code>，就可以得到数列的下一项。</p><h2 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h2><p>我们在矩阵快速幂的时候，指数的值应当是<code>n-2</code>而不是<code>n</code>。</p><h2 id="快在哪？"><a href="#快在哪？" class="headerlink" title="快在哪？"></a>快在哪？</h2><p><del>快速幂O(logn)递推O(n)你说快在哪？</del></p><h1 id="一些需要注意的地方"><a href="#一些需要注意的地方" class="headerlink" title="一些需要注意的地方"></a>一些需要注意的地方</h1><p>（感谢xht37帮我Debug…）</p><ul><li>在<strong>可以</strong>模<del>膜</del>的地方都模一下，可以防止爆精度<del>涨rp</del>。</li><li><strong>欧拉定理</strong>不能运用在矩阵快速幂中，模数是质数也不行（用在普通快速幂中也没觉得快多少？</li><li>数据类型一定要一致<del>不然会爆零</del></li></ul><p>差不多就这些了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;矩阵的存储&quot;&gt;&lt;a href=&quot;#矩阵的存储&quot; class=&quot;headerlink&quot; title=&quot;矩阵的存储&quot;&gt;&lt;/a&gt;矩阵的存储&lt;/h1&gt;&lt;p&gt;为方便编写函数，我们使用一个&lt;strong&gt;结构体&lt;/strong&gt;&lt;code&gt;Mat&lt;/code&gt;来存储一个矩阵。&lt;/p&gt;
&lt;p&gt;同时可以构造函数使矩阵元素的初始值为0。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mat&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m[N][N];&lt;span class=&quot;comment&quot;&gt;//N视情况而定&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mat()&amp;#123;&lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(m,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(m));&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习报告" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    
      <category term="矩阵快速幂" scheme="http://zgjjj.github.io/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>位运算与二进制状态压缩 学习报告</title>
    <link href="http://zgjjj.github.io/2019/02/26/%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://zgjjj.github.io/2019/02/26/位运算与二进制状态压缩-学习报告/</id>
    <published>2019-02-26T08:22:36.000Z</published>
    <updated>2019-02-28T07:10:34.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在计算机中，数据都使用二进制存储与操作。因此，学习位运算不仅可以优化我们的程序<del>（使可读性–）</del>，还可以帮助我们理解程序运行中的种种表现，帮助我们更好的DEBUG<del>（卡常）</del></p><a id="more"></a><p>学习资料：《进阶指南》</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="算术位运算"><a href="#算术位运算" class="headerlink" title="算术位运算"></a>算术位运算</h2><p>下面给出四种算术位运算：</p><table><thead><tr><th style="text-align:center">与</th><th style="text-align:center">或</th><th style="text-align:center">非</th><th style="text-align:center">亦或</th></tr></thead><tbody><tr><td style="text-align:center">and,&amp;</td><td style="text-align:center">or,\</td><td style="text-align:center"></td><td style="text-align:center">not,~</td><td>xor,^</td></tr></tbody></table><p>注意<strong>与</strong>和<strong>或</strong>运算与条件连接使用的与和或<strong>不同</strong>，<strong>非</strong>也从<code>!</code>变为<code>~</code>。</p><p>这些运算的意义不再赘述。</p><h2 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h2><h3 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h3><p>低位补0，高位越界舍弃。</p><p>对于左移操作，我们有：</p><p>$${1&lt;&lt;n=2^n,n&lt;&lt;k=2^k\times n}$$</p><h3 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h3><p>低位越界舍弃，高位以<strong>符号位</strong>补充。</p><p>对于右移操作，我们有：<br>$${n&gt;&gt;k=\lfloor{\dfrac{n}{2^k}}\rfloor}$$</p><h1 id="状压"><a href="#状压" class="headerlink" title="状压"></a>状压</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">运算</th></tr></thead><tbody><tr><td style="text-align:center">取出n的第k位</td><td style="text-align:center">(n&gt;&gt;k)&amp;1</td></tr><tr><td style="text-align:center">取出n的第0~k-1位</td><td style="text-align:center">n&amp;((1&lt;&lt;k)-1)</td></tr><tr><td style="text-align:center">n的第k位取反</td><td style="text-align:center">n^(1&lt;&lt;k)</td></tr><tr><td style="text-align:center">n的第k位赋1</td><td style="text-align:center">n\</td><td>(1&lt;&lt;k)</td></tr><tr><td style="text-align:center">n的第k位赋0</td><td style="text-align:center">n&amp;(~(1&lt;&lt;k))</td></tr></tbody></table><p><del>可以在脑中模拟一下，应该很好理解</del></p><h2 id="成对变换"><a href="#成对变换" class="headerlink" title="成对变换"></a>成对变换</h2><p>对于一个偶数${n}$，我们有${n+1=n \; xor \;1}$</p><p>同样的，对于一个奇数${n}$，我们有${n-1=n \; xor \;1}$</p><h3 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h3><p><strong>滚动数组</strong>和<strong>邻接表存反图</strong></p><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br></pre></td></tr></table></figure><p>这是代码，作用为取出数$x$的最低位的1。</p><p>运用了<strong>二进制补码</strong>的相关知识。<del>不再赘述</del></p><p>是<strong>树状数组</strong>的<strong>核心</strong>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>使用位运算可以<strong>显著优化运行时间</strong>，因此，<strong>在对程序可读性无重大影响</strong>的基础上，笔者会尽量使用位运算。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在计算机中，数据都使用二进制存储与操作。因此，学习位运算不仅可以优化我们的程序&lt;del&gt;（使可读性–）&lt;/del&gt;，还可以帮助我们理解程序运行中的种种表现，帮助我们更好的DEBUG&lt;del&gt;（卡常）&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习报告" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    
      <category term="位运算" scheme="http://zgjjj.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="状压" scheme="http://zgjjj.github.io/tags/%E7%8A%B6%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>字符串Hash 学习报告</title>
    <link href="http://zgjjj.github.io/2019/02/14/%E5%AD%97%E7%AC%A6%E4%B8%B2Hash-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://zgjjj.github.io/2019/02/14/字符串Hash-学习报告/</id>
    <published>2019-02-14T09:38:10.000Z</published>
    <updated>2019-02-14T10:03:51.317Z</updated>
    
    <content type="html"><![CDATA[<p>听julao xht的建议学了字符串哈希。<br><a id="more"></a></p><p>先挂一张图：</p><p><img src="https://i.loli.net/2019/02/14/5c6537a8a0050.jpg" alt=""></p><p>图源：xht 拍自<strong>《进阶指南》</strong></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>如书中所说，字符串hash可以将<strong>任何字符串</strong>映射成一个<strong>非负整数</strong>的值，从而方便进行比较。</p><h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><p>指两个或多个不同的字符串被映射到同一个<strong>非负整数</strong>的情况。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="如何求给定串的Hash值"><a href="#如何求给定串的Hash值" class="headerlink" title="如何求给定串的Hash值"></a>如何求给定串的Hash值</h2><p>首先选取一个<strong>固定值P</strong>（最好是质数），我们可以把字符串看成一个<strong>P进制数</strong>，以此映射到一个非负整数的值上。</p><p>接着选取一个<strong>固定模数M</strong>，将上述<strong>P进制数模M意义下的值</strong>作为<strong>原字符串</strong>的Hash值。</p><p>通常，我们选取$2^{64}$作为模数，这样就可以使用<strong>unsigned long long 类型</strong>来储存原P进制数，在大于模数M时自动溢出，可<strong>避免低效取模运算</strong>。</p><h2 id="如何处理hash冲突"><a href="#如何处理hash冲突" class="headerlink" title="如何处理hash冲突"></a>如何处理hash冲突</h2><p><strong>任何数据都无法避免Hash冲突</strong></p><p>我们可以做的，只是尽可能减少冲突概率。</p><p>有以下几种做法：</p><h3 id="在模数上"><a href="#在模数上" class="headerlink" title="在模数上"></a>在模数上</h3><p>对于P，我们可以选用<strong>P=131</strong>或<strong>P=13331</strong>。<del>对于M，我们可以选用19260817</del></p><h3 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h3><p>可以进行多组Hash，使用一个<strong>多元组</strong>储存不同hash的结果，在比对时逐次比对，可以<strong>有效降低</strong>Hash冲突。</p><h2 id="对应字符串的操作"><a href="#对应字符串的操作" class="headerlink" title="对应字符串的操作"></a>对应字符串的操作</h2><p>设$F[s]​$储存字符串$s​$的Hash值，那么对于一个新串$t​$，我们有</p><p>$${F[t]=(F[s+t]-F[s]*P^{strlen(t)})}$$</p><p>对应到P进制数上，就相当于<strong>左移操作</strong>。</p><p>当$t$为一个字符${c}$时，我们可以得到字符串Hash值的初始化公式：</p><p>$${F[s+c]=F[s]+p\times value[c]}$$</p><p>一般$value[c]$取$ASCII$码中字符c的对应值。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><del><a href="https://www.luogu.org/problemnew/show/P3370" target="_blank" rel="noopener">Luogu P3370 【模板】字符串哈希</a></del>(这题${Set}$和${Map}$可以水过)</p><p><a href="http://contest-hunter.org:83/contest/0x10%E3%80%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8D%E4%BE%8B%E9%A2%98/1401%20%E5%85%94%E5%AD%90%E4%B8%8E%E5%85%94%E5%AD%90" target="_blank" rel="noopener">CH1401 兔子与兔子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听julao xht的建议学了字符串哈希。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习报告" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    
      <category term="字符串" scheme="http://zgjjj.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Hash" scheme="http://zgjjj.github.io/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>裴蜀定理 学习报告</title>
    <link href="http://zgjjj.github.io/2019/02/13/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://zgjjj.github.io/2019/02/13/裴蜀定理-学习报告/</id>
    <published>2019-02-13T08:56:00.000Z</published>
    <updated>2019-02-13T09:15:33.350Z</updated>
    
    <content type="html"><![CDATA[<p><del>（这玩意真不难）</del></p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>会$gcd$就行了。</p><a id="more"></a><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>$$\forall a,b,x,y,d\in Z,ax+by=d当且仅当gcd(a,b)\mid d$$</p><h1 id="简要证明"><a href="#简要证明" class="headerlink" title="简要证明"></a>简要证明</h1><p>设$s=gcd(a,b)$，显然有$s\mid a$且${s\mid b}$</p><p>又因为${x,y\in Z}$，显然有$s\mid ax$且${s\mid by}$</p><p>所以${s\mid ax+by}$</p><p>又因为${ax+by=d}$</p><p>所以$s\mid d$</p><p>所以$gcd(a,b)\mid d$</p><h1 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h1><ol><li>方程$ax+by=1$有解当且仅当$x,y$互素</li><li>对于给定数列$\{a\}$,表达式$\sum\limits_{i=1}^na_ix_i&gt;0 $最小正整数值为${\gcd\limits_{1\le i\le n}\{|a_i|\}}$</li></ol><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><a href="https://www.luogu.org/problemnew/show/P4549" target="_blank" rel="noopener">P4549 【模板】裴蜀定理</a></p><p>直接运用推广2求解就好，记得取${|a_i|}$</p><p><del>(说了很简单)</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;（这玩意真不难）&lt;/del&gt;&lt;/p&gt;
&lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;p&gt;会$gcd$就行了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习报告" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    
      <category term="裴蜀定理" scheme="http://zgjjj.github.io/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"/>
    
      <category term="数论" scheme="http://zgjjj.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>表达式树及三序表达</title>
    <link href="http://zgjjj.github.io/2019/02/13/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%8F%8A%E4%B8%89%E5%BA%8F%E8%A1%A8%E8%BE%BE/"/>
    <id>http://zgjjj.github.io/2019/02/13/表达式树及三序表达/</id>
    <published>2019-02-13T06:59:30.000Z</published>
    <updated>2019-02-13T07:36:45.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>需要了解树的先序、中序、后序遍历</p><a id="more"></a><h1 id="先来看一道题目"><a href="#先来看一道题目" class="headerlink" title="先来看一道题目"></a>先来看一道题目</h1><p><img src="https://i.loli.net/2019/02/13/5c63c1b262992.jpg" alt=""></p><p>（源自洛谷有题）</p><p>这是2017年TG初赛试题，这篇文章主要讲述如何<strong>快速有效</strong>地解这一类题。</p><h1 id="关于表达式的三序表达"><a href="#关于表达式的三序表达" class="headerlink" title="关于表达式的三序表达"></a>关于表达式的三序表达</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们用一个例子来说明：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">表达式</th></tr></thead><tbody><tr><td style="text-align:center">中序表达式</td><td style="text-align:center">$2\times 3/(2-1)+3\times(4-1)$</td></tr><tr><td style="text-align:center">前序表达式</td><td style="text-align:center">$+/\times23-21*3-41$</td></tr><tr><td style="text-align:center">后序表达式</td><td style="text-align:center">$23\times21-/341-\times+$</td></tr></tbody></table><p>大致明白是什么了叭？</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>有人问：</p><blockquote><p>中序表达式这么方便，为什么还要开发<del>看不懂的</del>前序和后序表达式呢？</p></blockquote><p>原因很简单：<br><strong>中序表达式会使用括号</strong></p><p>这将极大程度影响（机器）运算的效率。</p><p>那么，对于前序和后序表达式，即使是同样的式子与操作符，不同的优先级都将导致其表达式的不同。也就不存在引用括号的情况。</p><h1 id="已知一个式子的中序表达，如何求它的前序和后序表达呢？"><a href="#已知一个式子的中序表达，如何求它的前序和后序表达呢？" class="headerlink" title="已知一个式子的中序表达，如何求它的前序和后序表达呢？"></a>已知一个式子的中序表达，如何求它的前序和后序表达呢？</h1><p>也很简单。</p><h2 id="引入一个概念：-表达式树"><a href="#引入一个概念：-表达式树" class="headerlink" title="引入一个概念： 表达式树"></a>引入一个概念： <strong>表达式树</strong></h2><p>我们来它长什么样：</p><p><img src="https://i.loli.net/2019/02/13/5c63c68026d33.png" alt=""></p><p>这是表达式${(1+2)-(3\times 4)}$的表达式树。</p><h2 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h2><ul><li>表达式树的叶节点<strong>能且仅能</strong>为运算数</li><li>除叶节点外的节点<strong>全部</strong>为操作符</li><li><p>节点的深度与运算的优先级正相关</p><p>根据以上三点，可以得到一个中序表达式的表达式树。</p></li></ul><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>通过这颗表达式树，我们很容易将中序表达式转化为<strong>等价</strong>的前序，后序表达式</p><p>如何转换？</p><p>得到一个中序表达式后，我们先将它转化为一颗表达式树。</p><p>例如上面的$(1+2)-(3\times 4)$</p><p><img src="https://i.loli.net/2019/02/13/5c63c68026d33.png" alt=""></p><p>转化后，对这棵树<strong>先序遍历</strong>，可以得到等价的前序表达式。</p><p>同样，对其<strong>后序遍历</strong>，可以得到等价的后序表达式。</p><p>这棵树的<strong>中序遍历</strong>，则是我们常用的中序表达式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;p&gt;需要了解树的先序、中序、后序遍历&lt;/p&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="http://zgjjj.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="学术" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P2822 组合数问题 解题报告</title>
    <link href="http://zgjjj.github.io/2019/02/13/%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://zgjjj.github.io/2019/02/13/组合数问题/</id>
    <published>2019-02-13T02:14:12.000Z</published>
    <updated>2019-02-13T03:09:45.227Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>暴力能拿90（雾</p></blockquote><a id="more"></a><p><img src="https://i.loli.net/2019/02/13/5c637f8a0d9b4.jpg" alt=""></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>组合数 ${C_n^m}$表示的是从${n}$ 个物品中选出${m}$个物品的方案数。举个例子，从 ${(1,2,3)}$三个物品中选择两个物品可以有 ${(1,2),(1,3),(2,3)}$这三种选择方法。根据组合数的定义，我们可以给出计算组合数${C_n^m}$的一般公式：</p><p>$${C_n^m=\frac{n!}{m!(n-m)!}}$$</p><p>其中${n!=\prod\limits_{i=1}^ni}$；特别地，定义${0!=1}$。</p><p>小葱想知道如果给定${n,m}$和${k}$，对于所有的${0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )}$有多少对 (i,j)(<em>i</em>,<em>j</em>) 满足${C_i^j}$是${k}$的倍数。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行有两个整数${t,k}$，其中代${t}$表该测试点总共有多少组测试数据，${k}$的意义见问题描述。</p><p>接下来${t}$行每行两个整数${n,m}$，其中${ n,m}$的意义见问题描述。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>共$t$行，每行一个整数代表所有的$0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$中有多少对$(i,j)$满足$C_i^j$是$k$的倍数。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><p>输出样例#1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>输入样例#2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 5</span><br><span class="line">4 5</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><p>输出样例#2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">7</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>【样例1说明】</p><p>在所有可能的情况中，只有$C_2^1 = 2$是2的倍数。</p><p>【子任务】</p><p><img src="https://cdn.luogu.org/upload/pic/3457.png" alt=""></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h2><p>照着题目打组合数公式。</p><p>优化的话，可以将阶乘打表，<del>或者写INT_128将$C_{0\le i\le 2000}^{0\le j \le i}$打表</del></p><p>很无脑，没写代码。</p><h2 id="50分做法"><a href="#50分做法" class="headerlink" title="50分做法"></a>50分做法</h2><p>打标算，多组数据输出不换行。</p><p>就像这样<img src="https://i.loli.net/2019/02/13/5c63845df123d.png" alt=""></p><h2 id="70分做法"><a href="#70分做法" class="headerlink" title="70分做法"></a>70分做法</h2><p>发现需求出$C_{0\le i\le n}^{0\le j\le \min(i,m)}$  </p><p>考虑组合数递推：<br>$$ C^m_n=C^{m-1}_{n-1}+C^{m-1}_n​$$</p><p>可${O(mn)}$预处理。</p><p>但需要注意<strong>初始化</strong>，即递推起点：<br>$${C_0^0=C_1^0=C_1^1=1}$$</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2000</span>;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="90分做法"><a href="#90分做法" class="headerlink" title="90分做法"></a>90分做法</h2><p>观察到<strong>多组数据模数一致</strong>，可以在预处理时取模。</p><h3 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2000</span>;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h2><p>观察到模数一致，考虑实现${O(1)}$查询：<br>用<strong>前缀和</strong>维护一个答案数组<code>ans[n][m]</code>，在预处理组合数时进行维护。</p><p>注意<strong>容斥</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans[i][j]=ans[i<span class="number">-1</span>][j]+ans[i][j<span class="number">-1</span>]-ans[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><p>注意对于当前数据的<strong>更新</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!c[i][j]) ans[i][j]++;</span><br></pre></td></tr></table></figure><p>注意答案<strong>传递</strong>：（想不明白可以画一个杨辉三角手玩）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans[i][i+<span class="number">1</span>]=ans[i][i];</span><br></pre></td></tr></table></figure><p>对于100分的做法，需要注意到$Sample\;2$：<br>在$Sample\; Input\; 2$中，出现了$m&gt;n$的<strong>违法情况</strong>，对于这类数据，在答案输出时特判，输出<code>ans[n][n]</code></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line">ll t,n,m,k,c[maxn][maxn],ans[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">c[<span class="number">0</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">0</span>]=c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">2000</span>;i++)&#123;</span><br><span class="line">c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%k;</span><br><span class="line">ans[i][j]=ans[i<span class="number">-1</span>][j]+ans[i][j<span class="number">-1</span>]-ans[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(!c[i][j]) ans[i][j]++;</span><br><span class="line">&#125;</span><br><span class="line">ans[i][i+<span class="number">1</span>]=ans[i][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;t,&amp;k);</span><br><span class="line">build();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,m&gt;n?ans[n][n]:ans[n][m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>这题坑不少，谈一谈作者实现时的问题：</p><ol><li>对于$m=0$的数据，快读有锅，应换用<strong>标准输入输出</strong>；</li><li>多组数据题，输出时<strong>一定要换行</strong>！<code>puts(&quot;&quot;);</code>；</li><li><strong>容斥</strong>和<strong>答案继承</strong>都是坑；</li><li>若非标算，在多组数据处理前应初始化<code>ans</code>；</li><li>目前没想到离线做法。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;暴力能拿90（雾&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="解题报告" scheme="http://zgjjj.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="组合数学" scheme="http://zgjjj.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="组合数递推" scheme="http://zgjjj.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>SDOI2009 SuperGCD解题报告(瞎搞)</title>
    <link href="http://zgjjj.github.io/2019/02/12/SuperGCD/"/>
    <id>http://zgjjj.github.io/2019/02/12/SuperGCD/</id>
    <published>2019-02-12T03:32:20.000Z</published>
    <updated>2019-02-18T05:15:56.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h1><p>高精求gcd</p><h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p><del>python不存在高精的</del></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><del>明明能更短</del><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> (__import__(<span class="string">'fractions'</span>).gcd(int(input()),int(input())))</span><br></pre></td></tr></table></figure></p><blockquote><p>人生苦短，我用python</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目简述&quot;&gt;&lt;a href=&quot;#题目简述&quot; class=&quot;headerlink&quot; title=&quot;题目简述&quot;&gt;&lt;/a&gt;题目简述&lt;/h1&gt;&lt;p&gt;高精求gcd&lt;/p&gt;
&lt;h1 id=&quot;思想&quot;&gt;&lt;a href=&quot;#思想&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="解题报告" scheme="http://zgjjj.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="py3" scheme="http://zgjjj.github.io/tags/py3/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树 学习报告</title>
    <link href="http://zgjjj.github.io/2019/02/11/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://zgjjj.github.io/2019/02/11/最小生成树-学习报告/</id>
    <published>2019-02-11T10:46:48.000Z</published>
    <updated>2019-02-12T03:39:21.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>给定一张无向图${G{(V,E)}}$中，${(u,v)}$代表连接顶点${u,v}$的边，${w(u,v)}$代表此边的<strong>权重</strong>，我们称它的一个<strong>无环</strong>子集${G’(V,E’)}$ <strong>（注意这里的${V}$与母集的${V}$一致）</strong> 为图${G}$的一个生成树。</p><a id="more"></a><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>一张图的生成树可以通过任意顶点<strong>dfs</strong>寻得。</p><p>这里是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10010</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn];<span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,u,v,w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x==i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(!vis[i]&amp;&amp;<span class="built_in">map</span>[i][x])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d -&gt; %d : %d\n"</span>,x,i,<span class="built_in">map</span>[x][i]);</span><br><span class="line">dfs(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line"><span class="built_in">map</span>[u][v]=w;</span><br><span class="line"><span class="built_in">map</span>[v][u]=w;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意</strong>：</h3><p>如果给定的图中存在一个环${C(V,E’)}$，即包含所有的顶点，那么此图的dfs生成树将会<strong>退化</strong>为<strong>链</strong>。</p><h4 id="典例："><a href="#典例：" class="headerlink" title="典例："></a>典例：<img src="https://i.loli.net/2019/02/11/5c616e8093a23.png" alt=""></h4><p>如果我们对此图求dfs生成树</p><p>将会得到如下结果：<br><img src="https://i.loli.net/2019/02/11/5c616eb76c076.png" alt=""></p><h3 id="另-自己在考场上发现的（除了我都知道的）知识："><a href="#另-自己在考场上发现的（除了我都知道的）知识：" class="headerlink" title="另:自己在考场上发现的（除了我都知道的）知识："></a><strong>另:</strong>自己在考场上发现的<del>（除了我都知道的）</del>知识：</h3><p>对于树${T(V,E)},\forall P \in V$作为其根节点，都将得到一颗树${T’}$。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="又称"><a href="#又称" class="headerlink" title="又称"></a>又称</h3><p><strong>用于多种不相交集合的数据结构</strong></p><h3 id="支持操作"><a href="#支持操作" class="headerlink" title="支持操作"></a>支持操作</h3><p>能够支持对于<strong>树</strong>的两种操作：</p><ol><li>查询一棵树的<strong>根节点</strong>；</li><li><strong>合并</strong>两棵树；</li></ol><h3 id="朴素代码"><a href="#朴素代码" class="headerlink" title="朴素代码"></a>朴素代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10010</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn];<span class="comment">//维护父节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">while</span>(n--)fa[n]=n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:find(fa[x]);&#125;<span class="comment">//递归实现查询</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx=find(x);<span class="keyword">int</span> yy=find(y);</span><br><span class="line">    fa[xx]=yy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>有<strong>路径压缩</strong>与<strong>按秩合并</strong>两种方法，这($zu\grave{o}​$)里($zh\check{e}​$)只($zh\check{i}​$)讲($hu\grave{i}​$)按秩合并：<br>思想：用<code>size[i]</code>维护以${i}​$为根节点的子树的大小，在合并时将小子树合并到大子树上。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10010</span></span><br><span class="line"><span class="keyword">int</span> fa[maxn],size[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">while</span>(n--) fa[n]=n,size[n]=<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx=find(x);<span class="keyword">int</span> yy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(size[xx]&gt;size[yy]) <span class="built_in">std</span>::swap(xx,yy);</span><br><span class="line">    fa[xx]=yy;size[yy]+=size[xx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MST（最小生成树），即为给定图的所有生成树中路径权值和最小的一个生成树。</p><p>求解有<code>Prim</code>和<code>Kruskal</code>两种算法。</p><p>下面将讲解<code>Kruskal</code>算法</p><h2 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>先将给定图的边按<strong>权值</strong>从小到大排序，然后利用<strong>并查集</strong>的思想，依次将权值最小的边的<strong>两个端点</strong>合并，保证了<strong>最小</strong>原则。在合并时，注意检查两颗子树是否隶属同一根节点，否则跳过，保证了<strong>无环</strong>原则。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 20010</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::sort;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">while</span>(n--)fa[n]=n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx=find(x);<span class="keyword">int</span> yy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(xx==yy) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fa[xx]=yy; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,w;</span><br><span class="line">&#125;a[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i].x,&amp;a[i].y,&amp;a[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(merge(a[i].x,a[i].y))&#123;</span><br><span class="line">            ans+=a[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意到一个性质"><a href="#注意到一个性质" class="headerlink" title="注意到一个性质"></a>注意到一个性质</h3><p>边按权值从小到大排序，每次仅取出最小边，可以考虑用<strong>堆</strong>来维护<del>（虽然被julao痛批但我一定要写上）</del></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 20010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node a)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.w&lt;w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">while</span>(n--) fa[n]=n;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx=find(x);<span class="keyword">int</span> yy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(xx==yy) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    fa[xx]=yy; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    init(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        node tmp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;tmp.x,&amp;tmp.y,&amp;tmp.w);</span><br><span class="line">        q.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(merge(tmp.x,tmp.y))&#123;</span><br><span class="line">            ans+=tmp.w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这里的堆并没有起到优化的作用，相反常数比sort大一些，仅供<del>喜欢</del>堆的选手使用）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;生成树&quot;&gt;&lt;a href=&quot;#生成树&quot; class=&quot;headerlink&quot; title=&quot;生成树&quot;&gt;&lt;/a&gt;生成树&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;给定一张无向图${G{(V,E)}}$中，${(u,v)}$代表连接顶点${u,v}$的边，${w(u,v)}$代表此边的&lt;strong&gt;权重&lt;/strong&gt;，我们称它的一个&lt;strong&gt;无环&lt;/strong&gt;子集${G’(V,E’)}$ &lt;strong&gt;（注意这里的${V}$与母集的${V}$一致）&lt;/strong&gt; 为图${G}$的一个生成树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习报告" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    
      <category term="MST" scheme="http://zgjjj.github.io/tags/MST/"/>
    
      <category term="Kruskal" scheme="http://zgjjj.github.io/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>扩展欧几里得 学习报告</title>
    <link href="http://zgjjj.github.io/2019/02/10/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <id>http://zgjjj.github.io/2019/02/10/扩展欧几里得算法/</id>
    <published>2019-02-10T11:54:15.000Z</published>
    <updated>2019-02-12T00:27:03.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="取模运算"><a href="#取模运算" class="headerlink" title="取模运算"></a>取模运算</h2><p>数${a}$对数${b}$取模，等价于数${a}$减去数${a}$除以数${b}$向下取整的商乘上数${b}$的差（好绕啊）。</p><a id="more"></a><p>其实就是下面这个式子：<br>$${a(mod\;b){\Longleftrightarrow}a-{\left\lfloor\dfrac{a}{b}\right\rfloor}\times b}$$<br>很好理解。</p><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p>数${a}$,${b}$的最大公约数指同时能够整除${a}$,${b}$的最大的正整数。记为 _gcd(a,b)_。</p><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><h2 id="欧几里得定理"><a href="#欧几里得定理" class="headerlink" title="欧几里得定理"></a>欧几里得定理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>又称<strong>辗转相除法</strong>，原理是这个式子：<br>$${gcd(a,b)=gcd(b,a(mod \; b))}$$<br>可以看出这个式子能够递归求解，递归边界为：<br>$${b=0}$$</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>${\forall a,b 且a&gt;b}$</p><p>若${b\mid a}$ ，显然有${gcd(a,b)=b}$.</p><p>考虑${b\nmid a}$：</p><p>不妨设${a=bk+c}​$，显然有$a\equiv c\pmod{b}​$.</p><p>设${d\mid a}$且${d\mid b}$，则${c=a-bk\frac{c}{d}=\frac{a}{d}-\frac{b}{d}k}$</p><p>故${d\mid c}$.</p><p>故${\forall c\mid a}$且${c\mid b}$，${c\mid a(mod\; b)}​$.</p><p>反过来，设${d\mid b}$ ${d\mid a(mod\; b)}$，同样有${\frac{a\;mod\;b}{d}=\frac{a}{d}-\frac{b}{d}k\frac{a\;mod\;b}{d}+\frac{b}{d}k=\frac{a}{d}}$.</p><p>故${d\mid a}$.</p><p>故${gcd(a,b)=gcd(b,a(mod\;b))}$.</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br></pre></td></tr></table></figure><p>很简单，一行就够了。</p><h1 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>解方程${ax+by=gcd(a,b)}​$</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>设${ax_1+by_1=gcd(a,b)}​$.                    ······①</p><p>${bx_2+a(mod\; b)y_2=gcd(b,a(mod\; b))}​$        ······②</p><p>由<strong>欧几里得定理</strong>：<br>${gcd(a,b)=gcd(b,a(mod\; b))}​$                ······③</p><p>由②③：</p><p>${bx_2+a(mod\; b)y_2=gcd(a,b)}​$                ······④</p><p>由①④：</p><p>${ax_1+by_1=bx_2+a(mod\;b)y_2}​$            ······⑤</p><p>由取模运算等价形式得：</p><p>${a(mod\; b)=a-{\left\lfloor\dfrac{a}{b}\right\rfloor}\times b}​$                    ······⑥</p><p>由⑤⑥：</p><p>${ax_1+by_1=bx_2+({a-{\left\lfloor\dfrac{a}{b}\right\rfloor}\times b})y_2}​$          ······⑦</p><p>由⑦移项得：</p><p>${ax_1+by_1=ay_2+b(x_2-{\left\lfloor\dfrac{a}{b}\right\rfloor}y_2)}​$         ······⑧</p><p>可得方程的一组<strong>可行解</strong>为：</p><p>$\begin{cases}{x_1=y_2}\\y_1=x_2-{\left\lfloor\dfrac{a}{b}\right\rfloor}y_2\end{cases}$                        ······⑨</p><p>由⑨得：<br>${\forall x_n,y_n\ne0}$，​${\begin{cases}x_n=y_{n+1}\\y_n=x_{n+1}-{\left\lfloor\dfrac{a}{b}\right\rfloor}y_{n+1}\end{cases}}$      ······⑩</p><p>即每一个${x,y}​$都可由上一层推出.</p><p>递归边界为：${b=0}​$，此时，x=1，y=0.</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> g=exgcd(b,a%b,y,x);y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="典例"><a href="#典例" class="headerlink" title="典例"></a>典例</h2><h3 id="题目链接：NOIP2012-同余方程"><a href="#题目链接：NOIP2012-同余方程" class="headerlink" title="题目链接：NOIP2012 同余方程"></a>题目链接：<a href="https://www.luogu.org/problemnew/show/P1082" target="_blank" rel="noopener">NOIP2012 同余方程</a></h3><h3 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h3><p>不妨将题目中的${ax\equiv 1\pmod{b}}$转化为${ax+by=1}$.</p><p>若要求${x}$的最小正整数解，很显然，${y}$为负数.</p><p>由<strong>裴蜀定理</strong>：${ax+by=1}$有解，当且仅当${a,b}$互素.</p><p>那么，${gcd(a,b)=1}$.</p><p>求出了${gcd(a,b)}$，就可以运用exgcd来求解.</p><p>需要注意的是，${exgcd}$求出的只是一组<strong>可行解</strong>，需对解出的${x}$进行调整使其成为最小正整数解.</p><p>如何调整？</p><p>仅需对x进行增减b的倍数的操作，使其<strong>恰大于0</strong>.</p><p>该操作可以简化为取模运算。</p><p>正确性可以这样理解：</p><p>因为${a,b}$互素，所以对于${x}$，对其增减任意倍数的${b}$，都能保证${b\mid (1-ax)}$.</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span>&amp; x,<span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    exgcd(b,a%b,y,x);y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;a,&amp;b);</span><br><span class="line">    exgcd(a,b,x,y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,(x+b)%b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;取模运算&quot;&gt;&lt;a href=&quot;#取模运算&quot; class=&quot;headerlink&quot; title=&quot;取模运算&quot;&gt;&lt;/a&gt;取模运算&lt;/h2&gt;&lt;p&gt;数${a}$对数${b}$取模，等价于数${a}$减去数${a}$除以数${b}$向下取整的商乘上数${b}$的差（好绕啊）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习报告" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    
      <category term="exgcd" scheme="http://zgjjj.github.io/tags/exgcd/"/>
    
  </entry>
  
  <entry>
    <title>To Do List</title>
    <link href="http://zgjjj.github.io/2019/02/10/To%20Do%20List/"/>
    <id>http://zgjjj.github.io/2019/02/10/To Do List/</id>
    <published>2019-02-10T09:01:49.000Z</published>
    <updated>2019-03-30T13:30:03.936Z</updated>
    
    <content type="html"><![CDATA[<p><del>显而易见搞不完</del><br><a id="more"></a></p><h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><ul><li>数学<ul><li style="list-style: none"><input type="checkbox" checked> 位运算（状压常用）</li><li style="list-style: none"><input type="checkbox"> 概率期望</li><li style="list-style: none"><input type="checkbox"> 群论</li><li>数论<ul><li style="list-style: none"><input type="checkbox"> 费马小定理</li><li style="list-style: none"><input type="checkbox"> 欧拉函数</li><li style="list-style: none"><input type="checkbox"> 中国剩余定理</li><li style="list-style: none"><input type="checkbox" checked> 逆元线性递推</li><li style="list-style: none"><input type="checkbox"> 线性筛</li><li style="list-style: none"><input type="checkbox" checked> 裴蜀定理</li><li style="list-style: none"><input type="checkbox"> BSGS</li><li style="list-style: none"><input type="checkbox"> 莫比乌斯反演</li><li style="list-style: none"><input type="checkbox"> 杜教筛</li></ul></li><li>线代<ul><li style="list-style: none"><input type="checkbox"> 矩阵求逆</li><li style="list-style: none"><input type="checkbox" checked> 矩阵快速幂</li><li style="list-style: none"><input type="checkbox"> 高斯消元</li><li style="list-style: none"><input type="checkbox"> 线性基</li></ul></li><li>组合<ul><li style="list-style: none"><input type="checkbox"> Lucas定理</li><li style="list-style: none"><input type="checkbox"> Catalan数</li><li style="list-style: none"><input type="checkbox"> 斯特林数</li><li style="list-style: none"><input type="checkbox" checked> 容斥</li><li style="list-style: none"><input type="checkbox"> 康托展开</li><li style="list-style: none"><input type="checkbox"> 鸽巢原理</li></ul></li><li>博弈论<ul><li style="list-style: none"><input type="checkbox" checked> Nim博弈</li><li style="list-style: none"><input type="checkbox"> SG函数</li></ul></li><li>多项式<ul><li style="list-style: none"><input type="checkbox"> DFT/IDFT</li><li style="list-style: none"><input type="checkbox"> FFT</li><li style="list-style: none"><input type="checkbox"> NTT</li><li style="list-style: none"><input type="checkbox"> FWT</li><li style="list-style: none"><input type="checkbox"> 拉格朗日插值</li><li style="list-style: none"><input type="checkbox"> 快速插值</li><li style="list-style: none"><input type="checkbox"> 求逆</li><li style="list-style: none"><input type="checkbox"> 开方</li><li style="list-style: none"><input type="checkbox"> 取对数</li><li style="list-style: none"><input type="checkbox"> 除法|取模</li><li style="list-style: none"><input type="checkbox"> 牛顿迭代</li></ul></li><li>杂<ul><li style="list-style: none"><input type="checkbox"> 0/1分数规划</li></ul></li></ul></li><li><p>动态规划</p><ul><li style="list-style: none"><input type="checkbox" checked> 记忆化搜索</li><li style="list-style: none"><input type="checkbox" checked> 区间DP</li><li style="list-style: none"><input type="checkbox"> 树形DP</li><li style="list-style: none"><input type="checkbox"> 状压DP</li><li style="list-style: none"><input type="checkbox"> 数位DP</li><li style="list-style: none"><input type="checkbox"> 插头DP</li><li style="list-style: none"><input type="checkbox"> DDP</li><li style="list-style: none"><input type="checkbox"> DP优化</li></ul></li><li><p>搜索</p><ul><li style="list-style: none"><input type="checkbox"> 双向BFS</li><li style="list-style: none"><input type="checkbox"> 迭代加深搜索</li><li style="list-style: none"><input type="checkbox"> ${\mathbf {A^*}}$</li><li style="list-style: none"><input type="checkbox"> $\mathbf{IDA^*} $</li><li style="list-style: none"><input type="checkbox"> DLX</li></ul></li><li>字符串<ul><li style="list-style: none"><input type="checkbox"> Hash</li><li style="list-style: none"><input type="checkbox"> KMP</li><li style="list-style: none"><input type="checkbox"> 回文自动机</li><li style="list-style: none"><input type="checkbox"> AC自动机</li><li style="list-style: none"><input type="checkbox"> <del>自动AC机</del></li><li style="list-style: none"><input type="checkbox"> 后缀数组</li><li style="list-style: none"><input type="checkbox"> 后缀自动机</li><li style="list-style: none"><input type="checkbox"> Manacher</li></ul></li><li>数据结构<ul><li style="list-style: none"><input type="checkbox" checked> 并查集</li><li style="list-style: none"><input type="checkbox"> 分块</li><li style="list-style: none"><input type="checkbox"> 哈希</li><li style="list-style: none"><input type="checkbox"> 单调栈</li><li style="list-style: none"><input type="checkbox"> 单调队列</li><li style="list-style: none"><input type="checkbox" checked> 树状数组(可能依然不会)</li><li style="list-style: none"><input type="checkbox" checked> 线段树</li><li style="list-style: none"><input type="checkbox"> zkw线段树</li><li style="list-style: none"><input type="checkbox"> 主席树</li><li style="list-style: none"><input type="checkbox" checked> Treap</li><li style="list-style: none"><input type="checkbox"> Splay</li><li style="list-style: none"><input type="checkbox"> LCT</li><li style="list-style: none"><input type="checkbox"> <del>红黑树</del></li><li style="list-style: none"><input type="checkbox"> fhq Treap</li><li style="list-style: none"><input type="checkbox"> 虚树</li><li style="list-style: none"><input type="checkbox"> 树套树</li><li style="list-style: none"><input type="checkbox"> K-Dtree</li></ul></li><li>图论<ul><li style="list-style: none"><input type="checkbox" checked> Dijkstra + Heap</li><li style="list-style: none"><input type="checkbox" checked> SPFA</li><li style="list-style: none"><input type="checkbox" checked> Floyd</li><li style="list-style: none"><input type="checkbox"> LCA</li><li style="list-style: none"><input type="checkbox"> 树剖</li><li style="list-style: none"><input type="checkbox" checked> Kruskal</li><li style="list-style: none"><input type="checkbox"> k短路</li><li style="list-style: none"><input type="checkbox"> 差分约束</li><li style="list-style: none"><input type="checkbox" checked> TopSort</li><li style="list-style: none"><input type="checkbox"> 强联通分量</li><li style="list-style: none"><input type="checkbox"> 双联通分量</li><li style="list-style: none"><input type="checkbox"> 2-SAT</li><li style="list-style: none"><input type="checkbox"> 二分图匹配</li><li>网络流<ul><li style="list-style: none"><input type="checkbox"> 最大流最小割</li><li style="list-style: none"><input type="checkbox"> 拆点</li><li style="list-style: none"><input type="checkbox"> 费用流</li><li style="list-style: none"><input type="checkbox"> 上下界网络流</li></ul></li></ul></li><li>计算几何<ul><li style="list-style: none"><input type="checkbox"> 三角剖分</li><li style="list-style: none"><input type="checkbox"> 凸包</li><li style="list-style: none"><input type="checkbox"> 扫描线</li><li style="list-style: none"><input type="checkbox"> 旋转卡壳</li><li style="list-style: none"><input type="checkbox"> 半平面交</li></ul></li><li>杂<ul><li style="list-style: none"><input type="checkbox"> CDQ分治</li><li style="list-style: none"><input type="checkbox"> 莫队</li><li style="list-style: none"><input type="checkbox"> 模拟退火SA</li><li style="list-style: none"><input type="checkbox"> 随机增量</li><li style="list-style: none"><input type="checkbox"> 读优</li><li style="list-style: none"><input type="checkbox" checked> 树上启发式合并</li><li style="list-style: none"><input type="checkbox"> 离散化</li></ul></li></ul><h1 id="复习计划"><a href="#复习计划" class="headerlink" title="复习计划"></a>复习计划</h1><ul><li style="list-style: none"><input type="checkbox" checked> 并查集</li><li style="list-style: none"><input type="checkbox"> dfs</li><li style="list-style: none"><input type="checkbox"> bfs</li><li style="list-style: none"><input type="checkbox"> Dijkstra+Heap</li><li style="list-style: none"><input type="checkbox"> SPFA</li><li style="list-style: none"><input type="checkbox"> 手写qsort(用处不大?)</li><li style="list-style: none"><input type="checkbox"> <del>打表</del></li><li style="list-style: none"><input type="checkbox" checked> 二分板子</li><li style="list-style: none"><input type="checkbox"> 三分</li><li style="list-style: none"><input type="checkbox" checked> 二维前缀和&amp;差分</li><li style="list-style: none"><input type="checkbox" checked> 线性DP</li><li style="list-style: none"><input type="checkbox" checked> <del>背包</del></li><li style="list-style: none"><input type="checkbox"> DFT/IDFT</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li><p>Nim博弈学习报告补锅</p></li><li><p>多项式学习报告补锅</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;显而易见搞不完&lt;/del&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="复习计划" scheme="http://zgjjj.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
      <category term="学习计划" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>2019寒假成都摸鱼记</title>
    <link href="http://zgjjj.github.io/2019/02/01/2019%E5%AF%92%E5%81%87%E6%88%90%E9%83%BD%E6%91%B8%E9%B1%BC%E8%AE%B0/"/>
    <id>http://zgjjj.github.io/2019/02/01/2019寒假成都摸鱼记/</id>
    <published>2019-02-01T11:38:02.000Z</published>
    <updated>2019-02-12T00:27:05.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>还没放寒假的时候就知道要出去了，<del>而且不用考生物</del>，也是比较期待吧，<del>于是肆意颓whk</del>。这篇游记是Day7晚上在火车上写的，大多数印象比较清晰，<del>知识点忘完了。</del></p><p>游记较长，大家可以<del>跳着看</del>。<br><a id="more"></a></p><h1 id="Day-inf"><a href="#Day-inf" class="headerlink" title="Day -inf"></a>Day -inf</h1><p>突然听说寒假要出去<del>玩</del>，还不用考<strong>生物</strong>，感觉很爽，也开始期待这场旅行<del>（颓文化课）</del>了。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>上午考完英语后，就往校门口跑。没到门口就看到我爹了，但没看到潘老师。打电话才知道去考场找我们去了，<del>假，连我在桌子上留的纸条都没看见</del>。总归是到校门口了，就往火车站走。<br>在<strong>赶时间</strong>的情况下，还在火车站对面的<strong>铁酒</strong>吃了一顿不错的午餐，<del>心真是大</del>。不过也没有很赶啦，着急地去了候车室后发现还早，就玩起了手机。<br>候车的时候吃逼乎的安利下了这个神奇的计算器：<code>Kalkyl</code><del>（真叫这个，不是乱码）</del></p><p><img src="https://i.loli.net/2019/02/01/5c5440281872b.png" alt=""></p><p>居然可以画图像！<del>虽然我严重怀疑这个${f(x)=x^x}$的图像画的有问题</del>.</p><p><img src="https://i.loli.net/2019/02/01/5c5440274ecb4.jpg" alt="">玩了会觉得没啥意思，然后就上车了。</p><p>在车上写了<strong><a href="https://zgjjj.github.io/2019/01/24/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/">贪心</a></strong>的学习报告。本来准备写完后写<strong>线性DP</strong>的，但是鉴于<strong>贪心</strong>写了1000+<del>（我太懒了）</del>，就没写了，开始颓<strong>CSGO</strong>。</p><p>打了一下午死斗，<del>全是机器人一点都不好玩</del>。手机也没有信号，又回忆起在重庆旅游时手机有信号没电的痛了……</p><p>补了《Unnatural》的第一话，太好看了wocccccccccc！！可为什么硕鼠不能下载收费视频啊QAQ。</p><p>也没有全程颓啦，<del>玩累了后</del>把洛谷blog上的文章搬到了hexo上，顺便修改了一下<del>补以前的锅</del>。</p><p>关于《巴黎圣母院》，<del>我忘了</del>。</p><p>晚上没睡好QAQ，对面的小孩是真的吵。就晕晕地睡了大概四个小时。</p><p>这无所事事的一天就过去了。</p><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>早上<code>6:00</code>到站，第一感觉就是，<del>火车站怎么跟襄阳站一样破</del>，才知道这是老城区。（去的照片搞丢了，这是回来的时候照的）</p><p><img src="https://i.loli.net/2019/02/10/5c5f72c25201a.png" alt="火车站"></p><p>出站后，找了好久才看到<del>龟缩在角落的</del>KFC，吃的也不算是丰盛。</p><p>实在是太困了…于是去了<strong>锦里</strong>的<strong>Starbucks</strong>，太早了人家都还没营业，好心的店主先把我们放进去了www。</p><p>待到了大概<code>9:30</code>的样子，回酒店了。<del>感觉从酒店去锦里的时间比从锦里去酒店的时间要长的多</del>。在酒店大堂看到了关老师<del>(没上一节课的班主任)</del>。</p><p>领了听课证、课表和笔记本后，就去吃午饭了。<strong>没吃火锅.难受.jpg</strong>。下午也没干啥，在酒店打了一下午<strong>LOL</strong>。</p><p>然后Day 0就结束了，依然无所事事。</p><h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>起的早，在食堂吃了早饭后，得知<strong>教室</strong>居然在食堂里面？？？不过还不错啦。</p><p>最开始是hcy老师讲<strong>搜索</strong>，<del>DFS我就没会过</del>，讲了个框架，剩下大部分是讲例题。<strong>八皇后</strong>到是会，但<strong>八数码</strong>是啥啊……讲八数码，hcy就开始讲<strong>Hash</strong>，说到Hash，我就想到一个月前在机房用<code>STL_Set</code>A掉的<strong>字符串哈希</strong>，但是八数码好像并不能用Set做……一整节课，基本上强制在线。</p><p><img src="https://i.loli.net/2019/02/01/5c539027c403b.jpg" alt=""></p><p>搜索终于讲完了，接着讲的是<strong>贪心</strong>，<del>这个我会</del>。</p><p><strong>国王游戏</strong>终于可以自己推了，高精依然不会<del>（想）</del>写。</p><p>贪心大概就是做题讲题做题讲题，知识性的东西并不多。</p><p>再然后就是<strong>分治与二分</strong>（没讲三分QAQ）。</p><p>思想还是清楚了，毕竟学过。然而在做题的时候发现自己打的好像是个假的二分板子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;=mid)mid=l;</span><br><span class="line">    <span class="keyword">else</span> mid=r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后自己的DEBUG套路好像也行不通了<del>（增减”=“号与+1或-1）</del>。</p><p>于是老老实实地就题论题打板子。</p><p>至于<strong>快速幂</strong>，讲的板子好像和我打的又不太一样<del>还好我那个也能用</del>。</p><p>晚上把部分题写了写，剩下了一些<del>（懒得）</del>难以实现的。</p><p>回到酒店后颓了几集《Unnatural》。</p><p>Day 1就结束了。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>没吃早饭（真的吃不下）</p><p>早上去了没来什么人？？？<del>（果然都吃早饭去了）</del></p><p>一整天都在讲<strong>数据结构</strong>。</p><blockquote><p>二叉堆？_priority_queue_就好了！</p><p>二叉搜索树？_set_就好了！</p><blockquote><p>改革春风吹满地，_STL_真争气。</p></blockquote></blockquote><p>然后就讲起了并查集。</p><p>板子还是比较熟的，不过老师没讲<strong>按秩合并</strong>，只讲了<strong>路径压缩</strong>。</p><p>这是<strong>按秩合并</strong>的板子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[maxn],size[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;fa[i]=i;size[i]=<span class="number">1</span>;&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx=find(x),yy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(size[xx]&gt;size[yy])swap(xx,yy);</span><br><span class="line">    fa[xx]=yy;size[yy]+=size[xx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲起了<strong>线段树</strong>：</p><p>我果然还是不会有灵魂（Lazy Tag ）的线段树QAQ。<del>懂是懂了，但是怎么实现啊</del></p><p>在luogu找了题解学习，大概明白怎么实现了。</p><p>讲完lazy tag，又讲了一大堆<del>玄学</del>？</p><p>那一刻，仿佛所有题都能套线段树A掉。<del>线段树太棒了</del></p><p><strong>树状数组</strong>离线了……<del>学不来</del><br>晚上写了一写题目，很多堆部分的练习以前都写过。</p><p>期望的<strong>RMQ和LCA</strong>都没有讲。</p><p>Day 2结束了。</p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>考试日。</p><p>上午在讲数论，并没有慌得一批。</p><p><strong>gcd</strong>有一个更加简短的实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> b?gcd(b,a%b):a;&#125;</span><br></pre></td></tr></table></figure><p><strong>lcm</strong>相对简单:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a*b/gcd(a,b);&#125;</span><br></pre></td></tr></table></figure><p>关于<strong>扩展欧几里得</strong>，以前打乘法逆元的板子时了解过，一直不会推，现在也会了。这里只给出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">int</span> g=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是筛法的预备知识：质数判定：</p><p>只需要枚举到${\sqrt n}​$就行了,但需要注意从2枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(n%i)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//一定要注意位运算符优先于算数运算符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<strong>埃氏筛</strong><del>（好久没打写挂了好几次）</del>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(check(i)&amp;&amp;!vis[i])&#123;</span><br><span class="line">is[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i;j&lt;=maxn;j+=i)&#123;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>质因数分解</strong>：不放在这了。</p><p>最后就是<strong>逆元</strong>了：</p><p>可以运用<strong>费马小定理</strong>：</p><p>${a^{p-1}}$ ≡ 1 (mod p),p为质数,a与p互质   （注意p为质数，不过noip如果要求逆元，p肯定是质数）</p><p>由此可得： a*${a^{p-2}}$ ≡ 1 (mod p)<br>所以，当模数为质数p时，a的逆元等于${a^{p-2}}$‘</p><p>当然也可以运用扩展欧几里得，这里不再赘述。</p><p>知识点就这些，也没写到什么题。下午就开始考试了。</p><p>这是题目：</p><p><img src="https://i.loli.net/2019/02/10/5c5f97153f1d0.png" alt=""></p><p>T1随便写<del>（虽然考场上没写优化挂了60分）</del></p><p>T2在考场上想了一个用set维护的骚操作，复杂度带log，<del>应该能过</del>，可惜最大值维护错了。</p><p>这是改后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) a&gt;b?a:b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;a;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">freopen(<span class="string">"guinness.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"guinness.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">int</span> m,x,n,t,cnt=<span class="number">1</span>,ans,maxx=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">a.insert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line">it=a.begin();ans=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);cnt=<span class="number">0</span>;<span class="keyword">int</span> tmp[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">tmp[++cnt]=x; <span class="keyword">bool</span> getans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(it,ans;it!=a.end();it++,ans++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;*it)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,ans);</span><br><span class="line">getans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!getans) <span class="built_in">printf</span>(<span class="string">"%d "</span>,a.size()+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(cnt) a.insert(tmp[cnt]),cnt--;</span><br><span class="line">&#125;</span><br><span class="line">fclose(<span class="built_in">stdin</span>);fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T3可以爆搜，但是没时间<del>（懒得写）</del>了，就没写，直接交上去了。</p><p>所以成绩并不是很好。</p><p>_Expected:140_  _Score:40_</p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>换老师了。</p><p>今天讲的是图论。</p><p>先讲了一大堆图的概念，学过了，所以在下面复习_Dijkstra+Heap_</p><p>然后开始讲图的存储方式，前向星听了一下，剩下的学过，继续颓_Dijkstra+Heap_</p><p>终于开始讲<strong>最短路</strong>了：<br>果然开始就讲Dijkstra…<del>没有堆优化太咸了!!!</del></p><p>于是继续颓_Dijkstra+Heap_…</p><p>讲完后开始讲<del>可爱的</del><strong>SPFA</strong>了，<a href="https://www.luogu.org/problemnew/show/P4779" target="_blank" rel="noopener">标准版的最短路</a>果然还是构造数据卡了SPFA。</p><p>挂个SPFA的工作图:</p><p><img src="https://i.loli.net/2019/02/10/5c5fccb038eeb.gif" alt=""></p><p>关于<strong>Bellman Ford</strong>，只是提了一下和SPFA很像，丢了一个blog链接，并没有细讲。</p><p>讲完单源，自然开始讲多源</p><p>多源自然讲了<del>可爱的</del>$O(n^3)$的<strong>Floyd</strong></p><p>五行代码真是太好了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j]&lt;<span class="built_in">map</span>[i][j])</span><br><span class="line">                <span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j];</span><br></pre></td></tr></table></figure><p>在做题的过程中学了一些<del>奇巧淫技</del>：</p><p>比如：</p><ol><li><p>多源一汇最短路径？存个反图跑<del>SPFA</del>:<img src="https://i.loli.net/2019/02/10/5c5fc356e5a24.png" alt=""></p></li><li><p><del>死掉的</del>SPFA也可以判负环：（代码摘自<a href="https://blog.csdn.net/update7/article/details/61932528" target="_blank" rel="noopener">这里</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(in));</span><br><span class="line">    fill(d, d + n, oo);</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>; vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        u = q.front();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = prev[u]; i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line">            v = edge[i].v;</span><br><span class="line">            <span class="keyword">if</span> (d[u] + edge[i].t &lt; d[v]) &#123;</span><br><span class="line">                d[v] = d[u] + edge[i].t;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                    in[v] ++;</span><br><span class="line">                    <span class="keyword">if</span> (in[v] &gt; n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>最短路讲完后是最小生成树，一样只是提了一下<strong>Prim</strong>，重点是<strong>Kruskal</strong>：<br>使用了<strong>并查集</strong>，也非常好理解：<br>直接给出代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:find(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx=find(x);<span class="keyword">int</span> yy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(xx!=yy)&#123;</span><br><span class="line">        fa[xx]=yy;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(merge(s[i].x,s[i].y))&#123;</span><br><span class="line">        sum+=s[i].w;cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好理解，于是讲的很快。</p><p>然后是<strong>TopSort</strong>（拓扑排序）：<br>相当于是寻找InDegree=0的点，push，然后删除。</p><p>也很好理解。代码实现：<del>(行吧这是课件上的代码我没看懂)</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(DirectGraph &amp;g,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;in_degree)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qu;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ite=in_degree.begin();ite !=in_degree.end();++ite)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*ite==<span class="number">0</span>)&#123;</span><br><span class="line">            qu.push(*ite);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> v=qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i:g.adj.at(v))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==--in_degree[i])&#123;</span><br><span class="line">                qu.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&gt;=v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后讲了树上倍增求LCA<del>（该来的总是会来）</del></p><p>知识听懂了，但是实现过程看的稀里糊涂的，<del>几乎强制在线</del></p><p><del>就像中国RMB一样</del>，每次都尝试最大的${2^i \leq n}$，总能凑出LCA位置，毕竟${2^0 =1}$嘛。</p><p>晚上写了个<a href="https://www.luogu.org/recordnew/show/15987514" target="_blank" rel="noopener">Dijkstra+Heap的A+B Problem</a><del>（我太咸了）</del></p><p>回酒店依然补剧…</p><h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>讲DP，本来满怀期待的，后来发现好多题以前都写过…</p><p>唯一值得一提的是<strong>01背包</strong>的原理又理解了一遍，比以前掌握的好多了。</p><p>Day 5没啥好写的。</p><h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>又是考试日。也换老师了。</p><p>上午讲的STL，也没啥好写的，会的以前都会，不会的比如<strong>全排列</strong>，无非感叹很有用，然后会用了，也没什么好说，<del>（所以这玩意真方便）</del>。</p><p>下午的考试：</p><p><img src="https://i.loli.net/2019/02/10/5c5fd93a32913.png" alt=""></p><p>解压后看T1，看了看数据范围，觉得60pts打表能出，很稳，就开了Excel，写T1 Expected 60</p><p>5分钟写了暴力挂在那打表，开始看T2。</p><p>T2感觉没啥思路，打暴力的时候把dfs忘了<del>（果然我还是不会dfs）</del>~写了${O(n^3)}$的存图，然后T1还没跑完，很慌，关了exe，把源程序的20改成了10打表，打开一看：</p><p><img src="https://i.loli.net/2019/02/10/5c5fdae126e66.png" alt=""></p><p>……</p><p><img src="https://i.loli.net/2019/02/10/5c5fdb6c3c0cf.png" alt=""></p><p>直接撸快速幂，100到手。</p><p>表变成了这个</p><p><img src="https://i.loli.net/2019/02/10/5c5fdbe24b8b2.png" alt=""></p><p><del>那个tip还是我手画了一棵树后验证的</del></p><p>实在想不出来，一脑抽，就把T1交了……</p><p>然后看到群里的：<img src="https://i.loli.net/2019/02/10/5c5fde6f3aa46.png" alt=""></p><p>然后….</p><p><img src="https://i.loli.net/2019/02/10/5c5fdebc81e6c.png" alt=""></p><p>……</p><p>不得不滚回去打T2了。</p><p>暴力写挂了……</p><p>T3依然不知道在讲什么。</p><p>所以考试算是半凉凉吧……</p><p>_Expected 160_ _Score=100_ </p><p>莫名rk3。</p><h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><p>上午讲了历年的一些题。</p><p>听懂了xkdyh的玄学解法，也会了货币系统<del>老凯的疑惑</del></p><p>心心念念的<strong>天天爱跑步</strong>没讲</p><p><del>直到Day 7我才知道原来课表里面没有<strong>KMP</strong></del></p><p>然后就结束了。</p><p>突然想到要滚回去上whk了，对这个地方还是有点不舍。</p><p>挂几张照片吧。</p><p><img src="https://i.loli.net/2019/02/10/5c5fe097ad366.jpg" alt=""></p><p><img src="https://i.loli.net/2019/02/10/5c5fe097b55fe.jpg" alt=""></p><p><img src="https://i.loli.net/2019/02/10/5c5fe097b7444.jpg" alt=""></p><p><img src="https://i.loli.net/2019/02/10/5c5fe097b94ac.jpg" alt=""></p><h1 id="Day-inf-1"><a href="#Day-inf-1" class="headerlink" title="Day inf"></a>Day inf</h1><p>卧在学校里，终于补了这篇游记的锅，虽然干货不多，但是知识点会慢慢写总结。</p><blockquote><p>做该做的，才对的起自己。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;还没放寒假的时候就知道要出去了，&lt;del&gt;而且不用考生物&lt;/del&gt;，也是比较期待吧，&lt;del&gt;于是肆意颓whk&lt;/del&gt;。这篇游记是Day7晚上在火车上写的，大多数印象比较清晰，&lt;del&gt;知识点忘完了。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;游记较长，大家可以&lt;del&gt;跳着看&lt;/del&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="游记" scheme="http://zgjjj.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P3406 海底高铁 解题报告</title>
    <link href="http://zgjjj.github.io/2019/01/24/%E6%B5%B7%E5%BA%95%E9%AB%98%E9%93%81/"/>
    <id>http://zgjjj.github.io/2019/01/24/海底高铁/</id>
    <published>2019-01-24T11:28:42.000Z</published>
    <updated>2019-02-11T01:51:47.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目链接-P3406-海底高铁"><a href="#题目链接-P3406-海底高铁" class="headerlink" title="题目链接:P3406 海底高铁"></a>题目链接:<a href="https://www.luogu.org/problemnew/show/P3406" target="_blank" rel="noopener">P3406 海底高铁</a></h3><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析:"></a>题目分析:</h3><p>​    <del>（第一眼以为是最短路）</del> 这道题作为前缀和的练习挺不错的，因为它<strong>几乎不涉及其他算法</strong>。<br>   <a id="more"></a><br>​    首先根据题目中的信息进行数据读入：<del>不开long long见祖宗（这题貌似不会）</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ll n,m,ans=<span class="number">0</span>;<span class="comment">//共N个城市,途经M个城市</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">ll p[m+<span class="number">1</span>];<span class="comment">//访问顺序</span></span><br><span class="line">ll t[n+<span class="number">1</span>]=&#123;&#125;;<span class="comment">//经过次数,一定要初始化！</span></span><br><span class="line">ll a[n+<span class="number">1</span>],b[n+<span class="number">1</span>],c[n+<span class="number">1</span>],x,y;<span class="comment">//a[i]纸质单程票,b[i]办卡后的优惠价,c[i]办卡工本费</span></span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;p[i]);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br></pre></td></tr></table></figure><p>​    由于<strong>第i段铁路连接了城市i和城市i+1</strong>，所以<strong>任意两个相邻的站点购买同种车票有且仅有一种费用</strong>，也就是说，价格仅与在某相邻两站之间的<strong>通过次数</strong>有关。此时，我们就将问题转化为<strong>求在给定路线下，每相邻两个站点路段的经过次数.</strong></p><p>​    那么，在出发之前，我们可以将每两站之间路段的经过次数<strong>全部初始化为0</strong>，然后，对每次给定的始发站和终到站，将其视作给定区间的两个端点，对此区间进行<strong>区间增</strong>操作。</p><h4 id="如何进行区间增呢？？？"><a href="#如何进行区间增呢？？？" class="headerlink" title="如何进行区间增呢？？？"></a>如何进行区间增呢？？？</h4><pre><code>首先这是给定的四个站点</code></pre><p><img src="https://i.loli.net/2018/12/15/5c14bd30327be.png" alt=""></p><p>​    如果我们按照1-3,3-2,2-4,4-3的顺序访问，可以发现四个站点间的路径经过次数是这样的：</p><table><thead><tr><th>路径</th><th>1-2</th><th>2-3</th><th>3-4</th></tr></thead><tbody><tr><td>次数</td><td>1</td><td>3</td><td>2</td></tr></tbody></table><p>​    一般的思路是，对于每个区间，用一个for对其所经次数++，然而我们发现，<strong>太慢了</strong>。</p><p>​    于是我们想到了<strong>前缀和</strong>：</p><p>对于每一个区间，我们可以在其<strong>左端点</strong>加上区间增的权值，再在<strong>右端点+1</strong>的位置减去区间增的权值，最后对该区间进行求前缀和操作。这样，我们可以得到一样的结果。</p><h4 id="回到题目中"><a href="#回到题目中" class="headerlink" title="回到题目中"></a>回到题目中</h4><p>​    恍然大悟，对于每组给定的区间端点，也可以使用同样的方法。更方便地，我们可以在对所有区间端点处理完毕后，在进行求前缀和操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于给定的信息是端点（城市），但是要求的是区间（路段），所以循环次数应为城市数-1</span></span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//对于端点的处理，要严格满足数学上的定义，小的在左端点，大的在右端点</span></span><br><span class="line">        <span class="comment">//否则对于逆序信息，就相当于进行了区间减操作</span></span><br><span class="line"><span class="keyword">if</span>(p[i]&gt;p[i+<span class="number">1</span>])&#123;</span><br><span class="line">x=p[i+<span class="number">1</span>];</span><br><span class="line">y=p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x=p[i];</span><br><span class="line">y=p[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//上面的代码可以简写为:</span></span><br><span class="line">    <span class="comment">//x=min(p[i],p[i+1]);</span></span><br><span class="line">        <span class="comment">//y=max(p[i],p[i+1]);</span></span><br><span class="line">t[x]++;<span class="comment">//左端点增</span></span><br><span class="line">t[y]--;<span class="comment">//右端点减</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求前缀和</span></span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">t[i]+=t[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    最后，对于每一段路径，总价值加上该段路径费用的较小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">ans+=min(a[i]*t[i],(b[i]*t[i]+c[i]));</span><br></pre></td></tr></table></figure><p>​    本题就解决啦！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) a&gt;b?a:b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) a&lt;b?a:b</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll n,m,ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">ll p[m+<span class="number">1</span>];</span><br><span class="line">ll t[n+<span class="number">1</span>]=&#123;&#125;;</span><br><span class="line">ll a[n+<span class="number">1</span>],b[n+<span class="number">1</span>],c[n+<span class="number">1</span>],x,y;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;p[i]);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a[i],&amp;b[i],&amp;c[i]);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]&gt;p[i+<span class="number">1</span>])&#123;</span><br><span class="line">x=p[i+<span class="number">1</span>];</span><br><span class="line">y=p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x=p[i];</span><br><span class="line">y=p[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">t[x]++;</span><br><span class="line">t[y]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">t[i]+=t[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">ans+=min(a[i]*t[i],(b[i]*t[i]+c[i]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目链接-P3406-海底高铁&quot;&gt;&lt;a href=&quot;#题目链接-P3406-海底高铁&quot; class=&quot;headerlink&quot; title=&quot;题目链接:P3406 海底高铁&quot;&gt;&lt;/a&gt;题目链接:&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3406&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P3406 海底高铁&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;题目分析&quot;&gt;&lt;a href=&quot;#题目分析&quot; class=&quot;headerlink&quot; title=&quot;题目分析:&quot;&gt;&lt;/a&gt;题目分析:&lt;/h3&gt;&lt;p&gt;​    &lt;del&gt;（第一眼以为是最短路）&lt;/del&gt; 这道题作为前缀和的练习挺不错的，因为它&lt;strong&gt;几乎不涉及其他算法&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="解题报告" scheme="http://zgjjj.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="前缀和" scheme="http://zgjjj.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="差分" scheme="http://zgjjj.github.io/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>贪心策略 学习报告</title>
    <link href="http://zgjjj.github.io/2019/01/24/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    <id>http://zgjjj.github.io/2019/01/24/贪心策略-学习报告/</id>
    <published>2019-01-24T04:01:07.000Z</published>
    <updated>2019-02-11T01:38:46.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>大胆贪心，<del>（不用）</del>小心证明。<br>——阮行止</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>贪心算法，本质上来讲不是一种算法，而是一种策略。其基本思路是在题解满足<strong>局部最优解</strong>将导致<strong>全局最优解</strong>时，每一次<strong>决策</strong>考虑且仅考虑当前最优解。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>就拿天朝RMB面额的设计来讲，仅举<strong>元</strong>这一单位，分别有<strong>1元，5元，10元，50元，100元</strong>五种面额。<br><strong>为什么要这样设计呢？</strong><br>在日常的生活中，我们买东西时就会发现，对于<strong>任意一个价格的商品</strong>，我们在购买时，要想花费最少张数的RMB，只需<strong>永远花费当前小于等于商品面额的货币</strong>。这就是一种贪心策略。</p><h2 id="例子的证明"><a href="#例子的证明" class="headerlink" title="例子的证明"></a>例子的证明</h2><p><del>我太菜了不会证</del>。</p><h1 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h1><h2 id="题意方面"><a href="#题意方面" class="headerlink" title="题意方面"></a>题意方面</h2><p>在<strong>定义</strong>中就提到过，要想使用贪心策略，<strong>一定</strong>要在题解满足<strong>局部最优解导致全局最优解</strong>。对于简单的贪心，<del>你看题面就知道这是个贪心</del>，而有技巧的贪心则需要自己的猜测<del>与证明</del>。</p><h2 id="关于局部最优解"><a href="#关于局部最优解" class="headerlink" title="关于局部最优解"></a>关于局部最优解</h2><p>局部最优解，即在<strong>当前局面看来</strong>，<strong>不考虑后续状态</strong>的情况下，结果最优的解。即是当前问题的一个<strong>子问题</strong>的最优解。</p><h2 id="贪心的证明"><a href="#贪心的证明" class="headerlink" title="贪心的证明"></a>贪心的证明</h2><p>贪心策略是需要证明的，至于严谨性就看个人对于答案的确信程度<del>和rp</del>。</p><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><h4 id="微扰法"><a href="#微扰法" class="headerlink" title="微扰法"></a>微扰法</h4><p>个人至今都不是很会的一种方法。<br>就是先假设一种贪心策略，再对该策略的局面做出<strong>所有</strong>可能的<strong>扰动</strong>（如交换相邻的两个元素），然后讨论扰动后的局面是否会造成<strong>更优的局面</strong>，若是，则原贪心策略被推翻；若对于所有的扰动局面，都有<strong>原贪心策略优于微扰后的策略</strong>，那么贪心成立。</p><h4 id="解集分析法"><a href="#解集分析法" class="headerlink" title="解集分析法"></a>解集分析法</h4><p>先枚举出<strong>小规模</strong>内的局面，若对于该规模问题，所有的解均能由<strong>同一种贪心策略</strong>取得，那么考虑该策略，扩大问题规模<del>（有点像迭代加深搜索）</del>，将该策略取得的解与枚举的解对比，若成立，则策略<strong>极有可能</strong>成立。<br><strong>注意这里的极有可能</strong>，<del>有些毒瘤数据可能刚好违背该策略</del>，所以这是一种不严谨的方法。</p><h4 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h4><p>我们先看个<strong>典例</strong>：</p><h5 id="排队打水问题"><a href="#排队打水问题" class="headerlink" title="排队打水问题"></a>排队打水问题</h5><pre><code>有n个人排队到r个水龙头去打水，他们装满水桶的时间t1、t2………..tn为整数且各不相等，应如何安排他们的打水顺序才能使他们总共花费的时间最少？ </code></pre><p>好像前面两种方法都行不通了？<del>其实我没试过</del><br>我没来看一个<strong>黑科技</strong>：</p><h5 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a><a href="https://baike.baidu.com/item/排序不等式/7775728?fr=aladdin" target="_blank" rel="noopener">排序不等式</a></h5><p>不等式的证明百科上讲的很清楚了，我就把结论挂在这吧：<br>$$\text{对于两个有序数组:$a_1\le a_2\le a_3\le …\le a_n$及$b_1\le b_2\le b_3\le …\le b_n$:}​$$</p><p>$$\sum\limits_{i=1}^na_ib_i\ge \sum\limits_{i=1}^na_ib_{j_i}\ge\sum\limits_{i=1}^na_ib_{n+1-i} $$</p><p>$${通俗来讲，就是顺序和\ge 乱序和\ge 逆序和}$$</p><p>那么，上面的例子就很好解决了吧？</p><p>总是规划打水时间最短者先打，再计算总打水时间，就可以得到最优的打水时间。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>正如<code>阮行止</code>所说,<code>“太贪心了是要栽跟头的。”</code>，贪心策略固可解决一部分题，但是，如果时时刻刻想着贪心，<del>DP也写贪心</del>，终究是得不到高分的。做人也正是如此吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;大胆贪心，&lt;del&gt;（不用）&lt;/del&gt;小心证明。&lt;br&gt;——阮行止&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习报告" scheme="http://zgjjj.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A/"/>
    
      <category term="贪心" scheme="http://zgjjj.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Luogu P1616 疯狂的采药 解题报告</title>
    <link href="http://zgjjj.github.io/2019/01/19/%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF/"/>
    <id>http://zgjjj.github.io/2019/01/19/疯狂的采药/</id>
    <published>2019-01-19T05:14:16.000Z</published>
    <updated>2019-01-24T04:03:41.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目链接-P1616-疯狂的采药"><a href="#题目链接-P1616-疯狂的采药" class="headerlink" title="题目链接:P1616 疯狂的采药"></a>题目链接:<a href="https://www.luogu.org/problemnew/show/P1616" target="_blank" rel="noopener">P1616 疯狂的采药</a></h2><h2 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h2><p><del>很明显的</del>完全背包。<br><a id="more"></a><br>首先，我们先把这道题转化为标准完全背包：</p><table><thead><tr><th style="text-align:center">各种草药</th><th style="text-align:center">物品</th></tr></thead><tbody><tr><td style="text-align:center"><strong>草药的价值</strong></td><td style="text-align:center"><strong>物品的价值</strong></td></tr><tr><td style="text-align:center"><strong>草药的采摘时间</strong></td><td style="text-align:center"><strong>物品的质量</strong></td></tr><tr><td style="text-align:center"><strong>总采摘时间</strong></td><td style="text-align:center"><strong>背包容量</strong></td></tr></tbody></table><p>ok,那么这道题就变成了板子题。</p><p>我们先来<strong>设计状态</strong>：</p><p>设<br>$$\text{dp[i]为背包容量为i时，能放下的物品的最大价值}$$</p><p>$$\text{t[j]与p[j]分别存储第j个物品的质量和价值}$$</p><p>然后进行<strong>状态转移</strong>：</p><p>对于容量为k的背包，第m个物品，我们考虑：</p><p>如果放这件物品，那么k容量背包的价值为dp[k-t[m]]+p[m]</p><p>如果不放，那么k容量背包的价值仍为原始的dp[k]</p><p>根据数组dp的定义，我们可以得到状态转移方程:</p><p>$$\text{dp[k]=max(dp[k-t[m]]+p[m],dp[k])}$$</p><p>同时，我们需要考虑该物品放入背包的先决条件：</p><p>$$\text{k-t[m]}\ge\text{0}$$</p><p>考虑每一件物品，并且综合上面的条件,我们得到了代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化，可通过将数组开在主函数外面省略这一步</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i-t[j]&gt;=<span class="number">0</span>) dp[i]=max(dp[i],dp[i-t[j]]+p[j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题所求的便是<strong>dp[T]。</strong></p><h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;T,&amp;n);</span><br><span class="line"><span class="keyword">int</span> t[n+<span class="number">1</span>],p[n+<span class="number">1</span>],dp[T+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t[i],&amp;p[i]);</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i-t[j]&gt;=<span class="number">0</span>) dp[i]=max(dp[i],dp[i-t[j]]+p[j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[T]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目链接-P1616-疯狂的采药&quot;&gt;&lt;a href=&quot;#题目链接-P1616-疯狂的采药&quot; class=&quot;headerlink&quot; title=&quot;题目链接:P1616 疯狂的采药&quot;&gt;&lt;/a&gt;题目链接:&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1616&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P1616 疯狂的采药&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;题目分析：&quot;&gt;&lt;a href=&quot;#题目分析：&quot; class=&quot;headerlink&quot; title=&quot;题目分析：&quot;&gt;&lt;/a&gt;题目分析：&lt;/h2&gt;&lt;p&gt;&lt;del&gt;很明显的&lt;/del&gt;完全背包。&lt;br&gt;
    
    </summary>
    
    
      <category term="解题报告" scheme="http://zgjjj.github.io/tags/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    
      <category term="线性DP" scheme="http://zgjjj.github.io/tags/%E7%BA%BF%E6%80%A7DP/"/>
    
  </entry>
  
</feed>
