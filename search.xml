<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HBTSC 2018 爆零记]]></title>
    <url>%2F2019%2F03%2F14%2FHBTSC-2018-%E7%88%86%E9%9B%B6%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[占坑，稳坐rk inf。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P4316 绿豆蛙的归宿 解题报告]]></title>
    <url>%2F2019%2F03%2F14%2F%E7%BB%BF%E8%B1%86%E8%9B%99%E7%9A%84%E5%BD%92%E5%AE%BF%2F</url>
    <content type="text"><![CDATA[手感太差了手写队列都能出锅 题目链接题目背景随着新版百度空间的上线，Blog宠物绿豆蛙完成了它的使命，去寻找它新的归宿。 题目描述给出一个有向无环图，起点为$1$终点为$N$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果有$K$条离开该点的道路，绿豆蛙可以选择任意一条道路离开该点，并且走向每条路的概率为 $1/K$ 。 现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？ 输入输出格式输入格式：第一行: 两个整数 N M，代表图中有N个点、M条边第二行到第 1+M 行: 每行3个整数 a b c，代表从a到b有一条长度为c的有向边 输出格式：从起点到终点路径总长度的期望值，四舍五入保留两位小数。 输入输出样例输入样例#1： 4 41 2 11 3 22 3 33 4 4 输出样例#1： 7.00 说明对于20%的数据 N&lt;=100 对于40%的数据 N&lt;=1000 对于60%的数据 N&lt;=10000 对于100%的数据 N&lt;=100000，M&lt;=2*N 分析算是概率期望DP比较简单的一道了。 考虑目标状态：从起点走到终点的所经过的路径总长度期望。 可以使用数组DP[i]来表示点$i$到终点所经路径的总长度期望。 目标状态即为DP[1]。 定义点$i$出度为k，对于每一个与点$i$联通的顶点$j$，根据期望的定义不难得出状态转移方程：$$DP[i] = \frac{1}{k}\sum\limits_{dist_{i,j}\neq INF}(DP[j]+dist_{i,j})$$ 可以在对DAG拓扑排序的同时完成状态转移。 一些细节这道题挺坑的明明是自己太菜了 说一说写的过程中犯的一些错误。 关于存图因为从终点状态确定，所以需要从终点往起点转移。对应地，图也应该存反图。 我一直以为反图只能跑多源一汇Dijkstra想不到还有这用处 关于邻接表自己写的时候又犯了初学时的错误… 四个数组大小都是醒目的N（head[]大小确实是$N$ 然后就一直70pts… 评测居然报的不是RE 关于队列第一次交题的时候看到有一个点T了，就换了手写队列，加了快读。 然而我已经几百年没碰手写队列了… 先把代码放着： 123456789struct queue &#123; int head, tail; int q[N]; inline void init() &#123;head = tail = 0;&#125; inline bool empty() &#123;return head &gt; tail;&#125; inline void push(int x) &#123;q[++tail] = x;&#125; inline void pop() &#123;head++;&#125; inline int front() &#123;return q[head];&#125;&#125;; 第一遍写的时候，把empty()里面的&gt;写成了- 这样的话，当head&lt;tail时，返回值应该是false，但原写法却返回了true。 关于Top Sort需要开两个数组来保存节点的度，然后Top Sort的时候仅对一个做出更改。 不然要么你拓扑排序会炸，要么你算的期望会炸。 关于前向星遍历没什么好说的，我太菜了才能把i = next[i]打成i++ 细节差不多就这些。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;cctype&gt;const int N = 1e5 + 6;const int M = N &lt;&lt; 1;namespace FastIO &#123; inline int read() &#123; int r = 0 , w = 1; char ch = getchar(); while(!isdigit(ch)) &#123;if(ch == '-') w = -1; ch = getchar();&#125; while(isdigit(ch)) &#123;r = r * 10 + ch - '0', ch = getchar();&#125; return r * w; &#125; inline void write(int x) &#123; if(x &lt; 0) putchar('-'); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0'); &#125; #define read() FastIO::read() #define write(x) FastIO::write(x)&#125;struct queue &#123; int head, tail; int q[N]; inline void init() &#123;head = tail = 0;&#125; inline bool empty() &#123;return head &gt; tail;&#125; inline void push(int x) &#123;q[++tail] = x;&#125; inline void pop() &#123;head++;&#125; inline int front() &#123;return q[head];&#125;&#125;;int edge[M] , ver[M] , next[M] , head[N] , cnt = 0;int out[N] , deg[N];int n, m;double dp[N];void Add(int x, int y, int z) &#123; edge[++cnt] = z, ver[cnt] = y, next[cnt] = head[x], head[x] = cnt;&#125;int main() &#123; n = read() , m = read(); for(register int i = 1 ; i &lt;= m ; i++) &#123; int x = read(), y = read(), z = read(); Add(y, x, z); out[x]++; deg[x]++; &#125; queue q; q.init(); q.push(n); while(!q.empty()) &#123; int now = q.front(); q.pop(); for(register int i = head[now] ; i ; i = next[i]) &#123; int to = ver[i]; dp[to] += (dp[now] + edge[i]) / out[to]; deg[to]--; if(deg[to] == 0) q.push(to); &#125; &#125; printf("%.2f",dp[1]); return 0;&#125; 吐槽一下luogu的玄学评测，应该RE的问题，吸氧TLE，不吸氧WA。太真实了。]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>概率期望DP</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式 学习报告]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[看过期的luogu网课学会了多项式 前置知识多项式定义由常数及未知数通过有限次乘法、加法以及自然数幂次乘方的组合，得到的代数表达式。 本文仅讨论单元多项式。 简记记$f(x) = \sum\limits_{i=0}^{n-1}a_ix^i$为一个n-1次多项式。 其中该多项式的次数为n-1，记为${\deg\;f = n-1}$。 对于该多项式次数为i的一项，我们记$f(x)[i]$为该项的系数${a_i}$，简写为$f[i]$。 算术运算设$f(x)=\sum\limits_{i=0}^{n-1}{a_ix^i},g(x)=\sum\limits_{i=0}^{n-1}b_ix^i$ 加减法$$(f+g)(x)=\sum\limits_{i=0}^{n-1}(a_i+b_i)\times x^i$$ $$(f-g)(x)=\sum\limits_{i=0}^{n-1}(a_i-b_i)\times x^i$$ 卷积（多项式乘法）$$(f\times g)(x)=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}a_i b_j \times x^{i+j}$$ 这个操作是$O(n^2)$的。 循环卷积$$(f \times g)(x) = \sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}a_ib_j\times x ^{[(i+j)(\mod n)]} $$ 复数 代数基本定理：任何一元n次方程在复数域内都恰好有n个解 虚数单位定义$i=\sqrt{-1}$，其中$i$被称为虚数单位。 复数复数集合符号为$\mathbb{C}$，$\mathbb{C}= \{ a+bi \mid a,b\in\mathbb R \} $ 对于一个复数$z=a+bi$: $a$被称为$z$的实部，记为$\mathbf {Re(z)}$ $b$被称为$z$的虚部，记为$\mathbf{lm(z)}$ 算术运算记$z_0,z_1\in\mathbb C,z_0=a_0+b_0i,z_1=a_1+b_1i$ 加减法$$z_0\pm z_1=(a_0\pm a_1)+(b_0 \pm b_1)i$$ 乘法$$z_0\times z_1 = (a_0a_1-b_0b_1)+(a_0b_1+a_1b_0)i$$ 可以将复数当成一个一次二项式来理解上面的式子。 复平面 复数$z=x+yi$与复平面上$(x,y)$一一对应。 $\varphi$为幅角，那么可以得到复数的三角表示： $$z=r\times (\cos \varphi+i\sin \varphi)$$ 欧拉定理$$e^{i\varphi}=\cos \varphi + i\sin \varphi$$ 模长表示复平面内向量${\vec z}$的模长，记为$\left|{z}\right|$ $$\left|z\right|=\sqrt{a^2+b^2}$$ 共轭表示复平面内与$z$关于x轴对称的点，记为$\bar z$ $$\overline z=a-bi$$ 不难得到: $$\overline zz=\left|z\right|^2$$ 共轭复数的四则运算都可以提取 $$\overline{z_0\pm z_1}=\overline{z_0}\pm\overline{z_1}$$ $$\lambda z=\lambda a+\lambda bi$$ $$\overline{z_0\times z_1}=\overline{z_0}\times \overline{z_1}$$ $$\frac{z_0}{z_1}=\frac{z_0\times \overline {z_1}}{\left|z_1\right|^2}$$ 三角表示的复数乘法 此部分内容来自课件 回顾复数乘法公式$$z_0 \times z_1 = (a_0a_1 + b_0b_1) + (a_0b_1 + a_1b_0) i$$，我们可以注意到$$\mathbf{Re}(z_0 \times z_1) = r_0 \cos\varphi_0 \times r_1 \cos\varphi_1-r_0 \sin\varphi_0 \times r_1 \sin\varphi_1 = r_0r_1 \times \cos(\varphi_0 +\varphi_1)$$，同时又有$$\mathbf{Im}(z_0 \times z_1) = r_0r_1 \times \sin (\varphi_0 + \varphi_1) $$。 尝试用三角表示改写乘法: $$(r_0 \times e^{i\varphi_0} ) \times (r_1 \times e^{i\varphi_1} ) = (r_0 \times r_1) \times e^{i(\varphi_0+\varphi_1)}$$ 棣莫弗定理$$z_0z_1 = r_0r_1 \times(cos(φ_0 + φ_1) + i \sin(φ_0 + φ_1))$$ 即两复数相乘的结果，模长为两者之积，幅角为二者之和。 棣莫弗公式： $$z^n = r^n \times (\cos(n\varphi) + i\sin(n\varphi))$$ 单位根满足方程$x^n = 1 $的所有的解，称为$n$次单位根。根据代数基本定理，$n$次方程在复数域内有$n$个解。 证明设$x=r\times (\cos \varphi+i\sin \varphi )$，若$x$是$n$次单位根，则： $\begin{cases}r^n=1\\\cos (n\varphi)=1\\\sin(n\varphi)=0\end{cases}$ 推导过程：$\qquad x^n=1$ $\Rightarrow(r\times (\cos \varphi+i\sin \varphi ))^n=1$ $\Rightarrow(r^n\times (\cos n\varphi+i\sin n\varphi))=1$ $\Rightarrow \sin n\varphi = 1$ $\Rightarrow \varphi=0$ $\Rightarrow \cos n\varphi = 1 $ $\Rightarrow r^n=1$ $\Rightarrow r= 1$ 那么，$r=1,\varphi=\frac{2\pi+k}{n}​$$k\in[0,n-1]\&amp; k\in\mathbb Z​$恰好是$x^n=1​$的$n​$个不同的解。 结合单位圆 很容易得到$n$个单位根分别为$e^{\frac{2k\pi }{n}i}$，$k\in[1,n-1]\&amp;k\in\mathbb Z$ 记单位圆根$\mathbf \omega_n=e^{\frac{\omega\pi}{n}i}$,则$n$个单位根又可以写成${\mathbf \omega_n^k},k\in[1,n-1]\&amp; k\in\mathbb Z$ 性质 $\mathbf \omega_n^m=\mathbf \omega_{n/k}^{m/k}​$ $\mathbf \omega_n^2=\mathbf \omega_{n/2}​$ $\mathbf \omega_n^j=- \mathbf \omega_n^{j+n/2}​$ $\sum\limits_{k=0}^{n-1}\mathbf \omega_n^{kt}={\begin{cases} n,n\mid t\\0,n\nmid t \end{cases}}​$(可通过等比数列求和证明) $[n\mid t]=\frac{1}{n}\sum\limits_{j=0}^{n-1}\mathbf \omega_n^{tj}​$(该性质是FFT的关键) 性质5中，[条件判断句1]运算符返回值为true当且仅当条件判断句1为真。 快速傅里叶变换 快速傅里叶变换(Fast Fourier Transform),即利用计算机计算离散傅里叶变换(DFT)的高效、快速计算方法的统称，简称FFT。快速傅里叶变换是1965年由J.W.库利和T.W.图基提出的。采用这种算法能使计算机计算离散傅里叶变换所需要的乘法次数大为减少，特别是被变换的抽样点数N越多，FFT算法计算量的节省就越显著。 来源：百度百科 推导记 $\deg\;f = \deg \; g = n - 1 ​$，$f​$与$g​$的循环卷积为$h​$ $\qquad h[z]​$ $\quad =\sum\limits_{x=0}^{n-1} \sum\limits_{y=0}^{n-1}f[x]\times g[y]\times [n\mid x+y-z]​$ $\quad =\sum\limits_{x=0}^{n-1} \sum\limits_{y=0}^{n-1}f[x]\times g[y]\times \frac{1}{n}\sum\limits_{t=0}^{n-1}\omega_n^{t(x+y-z)}​$ $\quad = \frac{1}{n}\sum\limits_{t=0}^{n-1}\omega_n^{-tz}(\sum\limits_{x=0}^{n-1}{f[x]\times \omega_n^{tx}})(\sum\limits_{y=0}^{n-1}g[y]\times \omega_n^{ty})​$ 设$F[t] = \sum\limits _{x=0} ^{n-1} f[x]\times \omega_n^{tx},G[t] = \sum\limits_{y=0}^{n-1}g[x]\times \omega_n^{ty},H[t] = F[t]\times G[t]$ 那么$h[t] = \frac{1}{n}\sum\limits_{x=0}^{n-1}H[x]\times \omega_n^{-tx}​$ 由$f,g$计算$F,G$的过程被称为离散傅里叶变换(Discrete Fourier Transform) 由$H计算h$的过程被称为离散傅里叶逆变换(Inverse Discrete Fourier Transform) 两者过程相差无几。 DFT现在仅考虑$n​$为偶数的情况。 给定$f​$，计算$F[t] = \sum\limits_{x=0}^{n-1}f[x] \times \omega _n^{tx}​$。 设$f_a=f[2k],f_b=f[2k+1],k\in\mathbb N​$ $$\therefore F_a[t] = \sum\limits_{a=0}^{n/2-1}f_a[a]\times \omega _{n/2}^{ta}​$$ $$\therefore F_b[t] = \sum \limits_{b=0}^{ n/2-1}f_b[b]\times \omega_{n/2}^{tb}​$$ 当$j&lt;n/2时$ $\therefore F[j] = \sum\limits_{a=0}^{n/2-1}\omega_n^{2a\times j}f[2a]+\sum\limits_{b=0}^{n/2-1}\omega_n^{(2b+1)\times j}f[2b+1]​$ $\quad \quad\quad =\sum\limits_{a=0}^{n/2-1}\omega_{n/2}^{a\times j}f_a[a]+\omega_{n}^j \times \sum\limits_{b=0}^{n/2-1}\omega _{n/2}^{b\times j}f_b[b]​$ $\quad \quad \quad =F_a[j]+\omega_n^jF_b[j]​$ 当$j\geqslant n/2$时 $\therefore F[j+n/2]=\sum\limits_{a=0}^{n/2-1}\omega_n^{2a\times (j+n/2)}f[2a]+\sum\limits_{b=0}^{n/2-1}\omega_n^{(2b+1)\times (j+n/2)}f[2b+1]​$ $\quad \quad \quad \quad \quad =\sum\limits_{a=0}^{n/2-1}\omega_{n/2}^{a}f_a[a]+\omega_n^{j+n/2}\times \sum\limits_{b=0}^{n/2-1}\omega_{n/2}^{b}f_b[b]$ $\quad \quad \quad \quad \quad =F_a[j]+\omega_n^{j+n/2}F_b[j]​$ $\quad \quad \quad \quad \quad =F_a[j]-\omega_n^jF_b[j]​$ 计算出$F_a$与$F_b$后，可以$O(n)$得到$F$,而$F_a,F_b$的计算都是项数为$n/2$的DFT，我们仅需递归求解规模为原问题规模一半的子问题。 边界情况：n=1。 由主定理：DFT的时间复杂度为$T(n)=2T(n/2)+O(n) =O(n\log n)$ IDFT与DFT区别不大，仅需将式中的$\omega_n^{j}$修改为$\omega _n ^{-j}$。]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nim博弈 学习报告]]></title>
    <url>%2F2019%2F03%2F05%2FNim%E5%8D%9A%E5%BC%88-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Nim取石子游戏甲，乙两个人玩Nim取石子游戏。nim游戏的规则是这样的：地上有n堆石子（每堆石子数量小于10000），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这n堆石子的数量，他想知道是否存在先手必胜的策略。 结论Nim博弈先手必胜，当且仅当：$$XOR_{a_1}^{a_n}=0$$ 证明（此部分搬运 y2823774827y的题解，在此对原作者表示敬意） 用比较通俗的方式讲一下吧： 题目本意是给出n堆石子，轮流在其中一堆去任意个，谁不能去谁就输。 思路：证明所有石子异或和为0则先手必输 证明： 反正最终情况就是每堆都为0，先手必输，所以我们考虑怎么把情况转换到这里。 如果异或和的最高位为i，则有一堆石子第i为为1（不然怎么会有i位） 设A1就为那堆石子，其他堆石子异或和设为x，总异或和设为k，则 A1 xor x=k，把A1变成A1 xor k，那么后手面对的则是（A1 xor k）xor x=0， 举个例子:11001 xor 11100=101，则有（11001 xor 101）xor 11100=0 如果现在的异或和已经为0了（不为最终情况），那么怎么转换异或和都不能为0 好，我们根据3 4点得出：如果先手异或和不为0，可以一步让后手的情况为异或和为0；如果先手异或和为0，那么后手异或和就不为0 终于开始进行游戏了，如果现在先手面对的情况异或和不为0，则一直让后手异或和为0，最后面对最终情况，后手输，则先手赢；如果先手面对的情况异或和为0，后手则赢 SG函数与ICG游戏（占坑，学了再写）]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>博弈论</tag>
        <tag>Nim博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂 学习报告]]></title>
    <url>%2F2019%2F03%2F05%2F%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[矩阵的存储为方便编写函数，我们使用一个结构体Mat来存储一个矩阵。 同时可以构造函数使矩阵元素的初始值为0。 1234struct mat &#123; int m[N][N];//N视情况而定 mat()&#123;memset(m,0,sizeof(m));&#125;&#125; 矩阵乘法定义对于大小为$n\times m​$的矩阵$A​$和大小为$n\times k​$的矩阵$B​$，规定$C=A\times B​$，其中：$$C_{i,j}=\sum\limits_{k=1}^{n}A_{i,p}*B_{p,j}​$$ 代码实现1234567891011mat mul(mat a, mat b) &#123; mat ans; for(register int i = 1 ; i &lt;= n ; i++) &#123; for(register int j = 1 ; j &lt;= n ; j++) &#123; for(register int k = 1 ; k &lt;= n ; k++) &#123; ans.m[i][j] += a.m[i][k] * b.m[k][j]; &#125; &#125; &#125; return ans;&#125; 普通快速幂这里只给出实现。 123456789int power(int a, int b) &#123; int ans = 1;//一定要记住初始值为1 while(b) &#123; if(b&amp;1) ans = ans * a; a*=a; b&gt;&gt;=1; &#125; return ans;&#125; 矩阵快速幂意义常用于加速递推。 实现我们结合普通快速幂的思想，将元素换为矩阵，不难得到下面的代码： 123456789mat power(mat a, int b) &#123; mat ans;//这里的ans已经初始化，具体看下文 while(b) &#123; if(b&amp;1) ans = mul(ans, a); a = mul(a, a); b&gt;&gt;=1; &#125; return ans;&#125; 看到代码里的注释了?矩阵$ans$同样是要初始化的，不同于普通快速幂，这里的$ans$应初始化为单位矩阵。（不知道是啥的，百度去吧）(应该没人不知道吧…) 123for(register int i = 1 ; i &lt;= n ; i++) &#123; ans.m[i][i] = 1;&#125; 我们往往把它封装在init()里面，因为在数列递推问题中，要初始化的还有$base$矩阵。 不同的写法（打mul()太累了？），我们还可以在结构体内重载*和*=运算符。没什么大的区别。 123456789101112131415struct mat &#123; int m[N][N]; mat()&#123;memset(m,0,sizeof(m));&#125; mat operator * (const mat &amp;a) const &#123; mat ans; for(register int i = 1 ; i &lt;= n ; i++) &#123; for(register int j = 1 ; j &lt;= n ; j++) &#123; for(register int k = 1 ; k &lt;= n ; k++) &#123; ans.m[i][j] += m[i][k] * a.m[k][j]; &#125; &#125; &#125; return ans; &#125;&#125; 那么，快速幂中的mul()就要换成*。 关于数列加速递推构造矩阵我讲不来怎么构造 为了使用矩阵快速幂，我们需要构造一个矩阵base，使得每乘一次base，就可以得到数列的下一项。 需要注意我们在矩阵快速幂的时候，指数的值应当是n-2而不是n。 快在哪？快速幂O(logn)递推O(n)你说快在哪？ 一些需要注意的地方（感谢xht37帮我Debug…） 在可以模膜的地方都模一下，可以防止爆精度涨rp。 欧拉定理不能运用在矩阵快速幂中，模数是质数也不行（用在普通快速幂中也没觉得快多少？ 数据类型一定要一致不然会爆零 差不多就这些了。]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算与二进制状态压缩 学习报告]]></title>
    <url>%2F2019%2F02%2F26%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[前言在计算机中，数据都使用二进制存储与操作。因此，学习位运算不仅可以优化我们的程序（使可读性–），还可以帮助我们理解程序运行中的种种表现，帮助我们更好的DEBUG（卡常） 学习资料：《进阶指南》 位运算算术位运算下面给出四种算术位运算： 与 或 非 亦或 and,&amp; or,\ not,~ xor,^ 注意与和或运算与条件连接使用的与和或不同，非也从!变为~。 这些运算的意义不再赘述。 移位左移低位补0，高位越界舍弃。 对于左移操作，我们有： $${1&lt;&lt;n=2^n,n&lt;&lt;k=2^k\times n}$$ 右移低位越界舍弃，高位以符号位补充。 对于右移操作，我们有：$${n&gt;&gt;k=\lfloor{\dfrac{n}{2^k}}\rfloor}$$ 状压基本操作 操作 运算 取出n的第k位 (n&gt;&gt;k)&amp;1 取出n的第0~k-1位 n&amp;((1&lt;&lt;k)-1) n的第k位取反 n^(1&lt;&lt;k) n的第k位赋1 n\ (1&lt;&lt;k) n的第k位赋0 n&amp;(~(1&lt;&lt;k)) 可以在脑中模拟一下，应该很好理解 成对变换对于一个偶数${n}$，我们有${n+1=n \; xor \;1}$ 同样的，对于一个奇数${n}$，我们有${n-1=n \; xor \;1}$ 运用滚动数组和邻接表存反图 lowbit1int lowbit(int x)&#123;return x&amp;-x;&#125; 这是代码，作用为取出数$x$的最低位的1。 运用了二进制补码的相关知识。不再赘述 是树状数组的核心。 后记使用位运算可以显著优化运行时间，因此，在对程序可读性无重大影响的基础上，笔者会尽量使用位运算。]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>位运算</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串Hash 学习报告]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%AD%97%E7%AC%A6%E4%B8%B2Hash-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[听julao xht的建议学了字符串哈希。 先挂一张图： 图源：xht 拍自《进阶指南》 简介意义如书中所说，字符串hash可以将任何字符串映射成一个非负整数的值，从而方便进行比较。 hash冲突指两个或多个不同的字符串被映射到同一个非负整数的情况。 流程如何求给定串的Hash值首先选取一个固定值P（最好是质数），我们可以把字符串看成一个P进制数，以此映射到一个非负整数的值上。 接着选取一个固定模数M，将上述P进制数模M意义下的值作为原字符串的Hash值。 通常，我们选取$2^{64}$作为模数，这样就可以使用unsigned long long 类型来储存原P进制数，在大于模数M时自动溢出，可避免低效取模运算。 如何处理hash冲突任何数据都无法避免Hash冲突 我们可以做的，只是尽可能减少冲突概率。 有以下几种做法： 在模数上对于P，我们可以选用P=131或P=13331。对于M，我们可以选用19260817 其他做法可以进行多组Hash，使用一个多元组储存不同hash的结果，在比对时逐次比对，可以有效降低Hash冲突。 对应字符串的操作设$F[s]​$储存字符串$s​$的Hash值，那么对于一个新串$t​$，我们有 $${F[t]=(F[s+t]-F[s]*P^{strlen(t)})}$$ 对应到P进制数上，就相当于左移操作。 当$t$为一个字符${c}$时，我们可以得到字符串Hash值的初始化公式： $${F[s+c]=F[s]+p\times value[c]}$$ 一般$value[c]$取$ASCII$码中字符c的对应值。 例题Luogu P3370 【模板】字符串哈希(这题${Set}$和${Map}$可以水过) CH1401 兔子与兔子]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>字符串</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[裴蜀定理 学习报告]]></title>
    <url>%2F2019%2F02%2F13%2F%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[（这玩意真不难） 前置知识会$gcd$就行了。 定理$$\forall a,b,x,y,d\in Z,ax+by=d当且仅当gcd(a,b)\mid d$$ 简要证明设$s=gcd(a,b)$，显然有$s\mid a$且${s\mid b}$ 又因为${x,y\in Z}$，显然有$s\mid ax$且${s\mid by}$ 所以${s\mid ax+by}$ 又因为${ax+by=d}$ 所以$s\mid d$ 所以$gcd(a,b)\mid d$ 推广 方程$ax+by=1$有解当且仅当$x,y$互素 对于给定数列$\{a\}$,表达式$\sum\limits_{i=1}^na_ix_i&gt;0 $最小正整数值为${\gcd\limits_{1\le i\le n}\{|a_i|\}}$ 应用P4549 【模板】裴蜀定理 直接运用推广2求解就好，记得取${|a_i|}$ (说了很简单)]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>裴蜀定理</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式树及三序表达]]></title>
    <url>%2F2019%2F02%2F13%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%8F%8A%E4%B8%89%E5%BA%8F%E8%A1%A8%E8%BE%BE%2F</url>
    <content type="text"><![CDATA[预备知识需要了解树的先序、中序、后序遍历 先来看一道题目 （源自洛谷有题） 这是2017年TG初赛试题，这篇文章主要讲述如何快速有效地解这一类题。 关于表达式的三序表达定义我们用一个例子来说明： 名称 表达式 中序表达式 $2\times 3/(2-1)+3\times(4-1)$ 前序表达式 $+/\times23-21*3-41$ 后序表达式 $23\times21-/341-\times+$ 大致明白是什么了叭？ 意义有人问： 中序表达式这么方便，为什么还要开发看不懂的前序和后序表达式呢？ 原因很简单：中序表达式会使用括号 这将极大程度影响（机器）运算的效率。 那么，对于前序和后序表达式，即使是同样的式子与操作符，不同的优先级都将导致其表达式的不同。也就不存在引用括号的情况。 已知一个式子的中序表达，如何求它的前序和后序表达呢？也很简单。 引入一个概念： 表达式树我们来它长什么样： 这是表达式${(1+2)-(3\times 4)}$的表达式树。 规定 表达式树的叶节点能且仅能为运算数 除叶节点外的节点全部为操作符 节点的深度与运算的优先级正相关 根据以上三点，可以得到一个中序表达式的表达式树。 转换通过这颗表达式树，我们很容易将中序表达式转化为等价的前序，后序表达式 如何转换？ 得到一个中序表达式后，我们先将它转化为一颗表达式树。 例如上面的$(1+2)-(3\times 4)$ 转化后，对这棵树先序遍历，可以得到等价的前序表达式。 同样，对其后序遍历，可以得到等价的后序表达式。 这棵树的中序遍历，则是我们常用的中序表达式。]]></content>
      <tags>
        <tag>技巧</tag>
        <tag>学术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P2822 组合数问题 解题报告]]></title>
    <url>%2F2019%2F02%2F13%2F%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[暴力能拿90（雾 题目题目描述组合数 ${C_n^m}$表示的是从${n}$ 个物品中选出${m}$个物品的方案数。举个例子，从 ${(1,2,3)}$三个物品中选择两个物品可以有 ${(1,2),(1,3),(2,3)}$这三种选择方法。根据组合数的定义，我们可以给出计算组合数${C_n^m}$的一般公式： $${C_n^m=\frac{n!}{m!(n-m)!}}$$ 其中${n!=\prod\limits_{i=1}^ni}$；特别地，定义${0!=1}$。 小葱想知道如果给定${n,m}$和${k}$，对于所有的${0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )}$有多少对 (i,j)(i,j) 满足${C_i^j}$是${k}$的倍数。 输入输出格式输入格式：第一行有两个整数${t,k}$，其中代${t}$表该测试点总共有多少组测试数据，${k}$的意义见问题描述。 接下来${t}$行每行两个整数${n,m}$，其中${ n,m}$的意义见问题描述。 输出格式：共$t$行，每行一个整数代表所有的$0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$中有多少对$(i,j)$满足$C_i^j$是$k$的倍数。 输入输出样例输入样例#1： 121 23 3 输出样例#1： 11 输入样例#2： 1232 54 56 7 输出样例#2： 1207 17 说明【样例1说明】 在所有可能的情况中，只有$C_2^1 = 2$是2的倍数。 【子任务】 分析30分做法照着题目打组合数公式。 优化的话，可以将阶乘打表，或者写INT_128将$C_{0\le i\le 2000}^{0\le j \le i}$打表 很无脑，没写代码。 50分做法打标算，多组数据输出不换行。 就像这样 70分做法发现需求出$C_{0\le i\le n}^{0\le j\le \min(i,m)}$ 考虑组合数递推：$$ C^m_n=C^{m-1}_{n-1}+C^{m-1}_n​$$ 可${O(mn)}$预处理。 但需要注意初始化，即递推起点：$${C_0^0=C_1^0=C_1^1=1}$$ 实现：123456789void build()&#123; c[0][0]=c[1][0]=c[1][1]=1; for(register int i=2;i&lt;=2000;i++)&#123; c[i][0]=1; for(register int j=1;j&lt;=i;j++)&#123; c[i][j]=(c[i-1][j-1]+c[i-1][j]); &#125; &#125;&#125; 90分做法观察到多组数据模数一致，可以在预处理时取模。 实现：123456789void build()&#123; c[0][0]=c[1][0]=c[1][1]=1; for(register int i=2;i&lt;=2000;i++)&#123; c[i][0]=1; for(register int j=1;j&lt;=i;j++)&#123; c[i][j]=(c[i-1][j-1]+c[i-1][j])%k; &#125; &#125;&#125; 100分做法观察到模数一致，考虑实现${O(1)}$查询：用前缀和维护一个答案数组ans[n][m]，在预处理组合数时进行维护。 注意容斥： 1ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1]; 注意对于当前数据的更新： 1if(!c[i][j]) ans[i][j]++; 注意答案传递：（想不明白可以画一个杨辉三角手玩） 1ans[i][i+1]=ans[i][i]; 对于100分的做法，需要注意到$Sample\;2$：在$Sample\; Input\; 2$中，出现了$m&gt;n$的违法情况，对于这类数据，在答案输出时特判，输出ans[n][n] 代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#define ll long longinline ll min(ll a,ll b)&#123;return a&lt;b?a:b;&#125;const int maxn = 2010;ll t,n,m,k,c[maxn][maxn],ans[maxn][maxn];inline void build()&#123; c[0][0]=c[1][0]=c[1][1]=1; for(register int i=2;i&lt;=2000;i++)&#123; c[i][0]=1; for(register int j=1;j&lt;=i;j++)&#123; c[i][j]=(c[i-1][j-1]+c[i-1][j])%k; ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1]; if(!c[i][j]) ans[i][j]++; &#125; ans[i][i+1]=ans[i][i]; &#125;&#125;int main()&#123; scanf("%lld%lld",&amp;t,&amp;k); build(); while(t--)&#123; scanf("%lld%lld",&amp;n,&amp;m); printf("%lld\n",m&gt;n?ans[n][n]:ans[n][m]); &#125; return 0;&#125; 注意事项这题坑不少，谈一谈作者实现时的问题： 对于$m=0$的数据，快读有锅，应换用标准输入输出； 多组数据题，输出时一定要换行！puts(&quot;&quot;);； 容斥和答案继承都是坑； 若非标算，在多组数据处理前应初始化ans； 目前没想到离线做法。]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>组合数学</tag>
        <tag>组合数递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDOI2009 SuperGCD解题报告(瞎搞)]]></title>
    <url>%2F2019%2F02%2F12%2FSuperGCD%2F</url>
    <content type="text"><![CDATA[题目简述高精求gcd 思想python不存在高精的 代码明明能更短1print (__import__('fractions').gcd(int(input()),int(input()))) 人生苦短，我用python]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>py3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树 学习报告]]></title>
    <url>%2F2019%2F02%2F11%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[预备知识生成树概念给定一张无向图${G{(V,E)}}$中，${(u,v)}$代表连接顶点${u,v}$的边，${w(u,v)}$代表此边的权重，我们称它的一个无环子集${G’(V,E’)}$ （注意这里的${V}$与母集的${V}$一致） 为图${G}$的一个生成树。 求法一张图的生成树可以通过任意顶点dfs寻得。 这里是代码： 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#define maxn 10010int map[maxn][maxn];bool vis[maxn];int n,m,u,v,w;void dfs(int x)&#123; vis[x]=1; for(register int i=1;i&lt;=n;i++)&#123; if(x==i) continue; if(!vis[i]&amp;&amp;map[i][x])&#123; printf("%d -&gt; %d : %d\n",x,i,map[x][i]); dfs(i); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(register int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); map[u][v]=w; map[v][u]=w; &#125; dfs(1); return 0;&#125; 注意：如果给定的图中存在一个环${C(V,E’)}$，即包含所有的顶点，那么此图的dfs生成树将会退化为链。 典例：如果我们对此图求dfs生成树 将会得到如下结果： 另:自己在考场上发现的（除了我都知道的）知识：对于树${T(V,E)},\forall P \in V$作为其根节点，都将得到一颗树${T’}$。 并查集又称用于多种不相交集合的数据结构 支持操作能够支持对于树的两种操作： 查询一棵树的根节点； 合并两棵树； 朴素代码12345678#define maxn 10010int fa[maxn];//维护父节点void init(int n)&#123;while(n--)fa[n]=n;&#125;int find(int x)&#123;return fa[x]==x?x:find(fa[x]);&#125;//递归实现查询void merge(int x,int y)&#123; int xx=find(x);int yy=find(y); fa[xx]=yy;&#125; 优化有路径压缩与按秩合并两种方法，这($zu\grave{o}​$)里($zh\check{e}​$)只($zh\check{i}​$)讲($hu\grave{i}​$)按秩合并：思想：用size[i]维护以${i}​$为根节点的子树的大小，在合并时将小子树合并到大子树上。 代码123456789#define maxn 10010int fa[maxn],size[maxn];void init(int n)&#123;while(n--) fa[n]=n,size[n]=1;&#125;int find(int x)&#123;return fa[x]==x?x:find(fa[x]);&#125;void merge(int x,int y)&#123; int xx=find(x);int yy=find(y); if(size[xx]&gt;size[yy]) std::swap(xx,yy); fa[xx]=yy;size[yy]+=size[xx];&#125; 最小生成树简介MST（最小生成树），即为给定图的所有生成树中路径权值和最小的一个生成树。 求解有Prim和Kruskal两种算法。 下面将讲解Kruskal算法 克鲁斯卡尔算法介绍先将给定图的边按权值从小到大排序，然后利用并查集的思想，依次将权值最小的边的两个端点合并，保证了最小原则。在合并时，注意检查两颗子树是否隶属同一根节点，否则跳过，保证了无环原则。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define maxn 10010#define maxm 20010using std::sort;int fa[maxn];void init(int n)&#123;while(n--)fa[n]=n;&#125;int find(int x)&#123;return fa[x]==x?x:find(fa[x]);&#125;bool merge(int x,int y)&#123; int xx=find(x);int yy=find(y); if(xx==yy) return 0; fa[xx]=yy; return 1;&#125;struct node&#123; int x,y,w;&#125;a[maxm];bool cmp(node a,node b)&#123;return a.w&lt;b.w;&#125;int main()&#123; int n,m,ans=0,cnt=0; scanf("%d%d",&amp;n,&amp;m); init(n); for(register int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].w); &#125; sort(a,a+m,cmp); for(register int i=1;i&lt;=m;i++)&#123; if(merge(a[i].x,a[i].y))&#123; ans+=a[i].w; cnt++; &#125; if(cnt==n-1)&#123; printf("%d",ans); break; &#125; &#125; return 0;&#125; 注意到一个性质边按权值从小到大排序，每次仅取出最小边，可以考虑用堆来维护（虽然被julao痛批但我一定要写上） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;queue&gt;#define maxn 10010#define maxm 20010using namespace std;struct node&#123; int x,y,w; bool operator &lt; (const node a)const&#123; return a.w&lt;w; &#125;&#125;;priority_queue&lt;node&gt; q;int fa[maxn]; void init(int n)&#123;while(n--) fa[n]=n;&#125;int find(int x)&#123;return fa[x]==x?x:find(fa[x]);&#125;bool merge(int x,int y)&#123; int xx=find(x);int yy=find(y); if(xx==yy) return 0; fa[xx]=yy; return 1;&#125;int main()&#123; int n,m,ans=0,cnt=0; scanf("%d%d",&amp;n,&amp;m); init(n); for(register int i=1;i&lt;=m;i++)&#123; node tmp; scanf("%d%d%d",&amp;tmp.x,&amp;tmp.y,&amp;tmp.w); q.push(tmp); &#125; for(register int i=1;i&lt;=m;i++)&#123; node tmp=q.top(); q.pop(); if(merge(tmp.x,tmp.y))&#123; ans+=tmp.w; cnt++; &#125; if(cnt==n-1)&#123; printf("%d",ans); break; &#125; &#125; return 0;&#125; （这里的堆并没有起到优化的作用，相反常数比sort大一些，仅供喜欢堆的选手使用）]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>MST</tag>
        <tag>Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展欧几里得 学习报告]]></title>
    <url>%2F2019%2F02%2F10%2F%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[预备知识取模运算数${a}$对数${b}$取模，等价于数${a}$减去数${a}$除以数${b}$向下取整的商乘上数${b}$的差（好绕啊）。 其实就是下面这个式子：$${a(mod\;b){\Longleftrightarrow}a-{\left\lfloor\dfrac{a}{b}\right\rfloor}\times b}$$很好理解。 最大公约数数${a}$,${b}$的最大公约数指同时能够整除${a}$,${b}$的最大的正整数。记为 _gcd(a,b)_。 引子欧几里得定理原理又称辗转相除法，原理是这个式子：$${gcd(a,b)=gcd(b,a(mod \; b))}$$可以看出这个式子能够递归求解，递归边界为：$${b=0}$$ 证明${\forall a,b 且a&gt;b}$ 若${b\mid a}$ ，显然有${gcd(a,b)=b}$. 考虑${b\nmid a}$： 不妨设${a=bk+c}​$，显然有$a\equiv c\pmod{b}​$. 设${d\mid a}$且${d\mid b}$，则${c=a-bk\frac{c}{d}=\frac{a}{d}-\frac{b}{d}k}$ 故${d\mid c}$. 故${\forall c\mid a}$且${c\mid b}$，${c\mid a(mod\; b)}​$. 反过来，设${d\mid b}$ ${d\mid a(mod\; b)}$，同样有${\frac{a\;mod\;b}{d}=\frac{a}{d}-\frac{b}{d}k\frac{a\;mod\;b}{d}+\frac{b}{d}k=\frac{a}{d}}$. 故${d\mid a}$. 故${gcd(a,b)=gcd(b,a(mod\;b))}$. 代码实现1int gcd(int a,int b)&#123;return b?gcd(b,a%b):a;&#125; 很简单，一行就够了。 扩展欧几里得用途解方程${ax+by=gcd(a,b)}​$ 推导设${ax_1+by_1=gcd(a,b)}​$. ······① ${bx_2+a(mod\; b)y_2=gcd(b,a(mod\; b))}​$ ······② 由欧几里得定理：${gcd(a,b)=gcd(b,a(mod\; b))}​$ ······③ 由②③： ${bx_2+a(mod\; b)y_2=gcd(a,b)}​$ ······④ 由①④： ${ax_1+by_1=bx_2+a(mod\;b)y_2}​$ ······⑤ 由取模运算等价形式得： ${a(mod\; b)=a-{\left\lfloor\dfrac{a}{b}\right\rfloor}\times b}​$ ······⑥ 由⑤⑥： ${ax_1+by_1=bx_2+({a-{\left\lfloor\dfrac{a}{b}\right\rfloor}\times b})y_2}​$ ······⑦ 由⑦移项得： ${ax_1+by_1=ay_2+b(x_2-{\left\lfloor\dfrac{a}{b}\right\rfloor}y_2)}​$ ······⑧ 可得方程的一组可行解为： $\begin{cases}{x_1=y_2}\\y_1=x_2-{\left\lfloor\dfrac{a}{b}\right\rfloor}y_2\end{cases}$ ······⑨ 由⑨得：${\forall x_n,y_n\ne0}$，​${\begin{cases}x_n=y_{n+1}\\y_n=x_{n+1}-{\left\lfloor\dfrac{a}{b}\right\rfloor}y_{n+1}\end{cases}}$ ······⑩ 即每一个${x,y}​$都可由上一层推出. 递归边界为：${b=0}​$，此时，x=1，y=0. 代码实现12345void exgcd(int a,int b,int&amp; x,int &amp;y)&#123; if(!b)&#123;x=1,y=0;return;&#125; int g=exgcd(b,a%b,y,x);y-=a/b*x; return;&#125; 典例题目链接：NOIP2012 同余方程推导过程不妨将题目中的${ax\equiv 1\pmod{b}}$转化为${ax+by=1}$. 若要求${x}$的最小正整数解，很显然，${y}$为负数. 由裴蜀定理：${ax+by=1}$有解，当且仅当${a,b}$互素. 那么，${gcd(a,b)=1}$. 求出了${gcd(a,b)}$，就可以运用exgcd来求解. 需要注意的是，${exgcd}$求出的只是一组可行解，需对解出的${x}$进行调整使其成为最小正整数解. 如何调整？ 仅需对x进行增减b的倍数的操作，使其恰大于0. 该操作可以简化为取模运算。 正确性可以这样理解： 因为${a,b}$互素，所以对于${x}$，对其增减任意倍数的${b}$，都能保证${b\mid (1-ax)}$. 代码实现1234567891011121314#include&lt;cstdio&gt;long long a,b,x,y;void exgcd(long long a,long long b,long long&amp; x,long long &amp;y)&#123; if(!b)&#123;x=1,y=0;return;&#125; exgcd(b,a%b,y,x);y-=a/b*x; return;&#125;int main()&#123; scanf("%lld %lld",&amp;a,&amp;b); exgcd(a,b,x,y); printf("%d",(x+b)%b); return 0;&#125;]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[To Do List]]></title>
    <url>%2F2019%2F02%2F10%2FTo%20Do%20List%2F</url>
    <content type="text"><![CDATA[显而易见搞不完 学习计划 数学 位运算（状压常用） 概率期望 群论 数论 费马小定理 欧拉函数 中国剩余定理 逆元线性递推 线性筛 裴蜀定理 BSGS 莫比乌斯反演 杜教筛 线代 矩阵求逆 矩阵快速幂 高斯消元 线性基 组合 Lucas定理 Catalan数 斯特林数 容斥 康托展开 鸽巢原理 博弈论 Nim博弈 SG函数 多项式 DFT/IDFT FFT NTT FWT 拉格朗日插值 快速插值 求逆 开方 取对数 除法|取模 牛顿迭代 杂 0/1分数规划 [ ] 动态规划 记忆化搜索 区间DP 树形DP 状压DP 数位DP 插头DP DDP DP优化 搜索 双向BFS 迭代加深搜索 ${\mathbf {A^*}}$ $\mathbf{IDA^*} $ DLX 字符串 Hash KMP 回文自动机 AC自动机 自动AC机 后缀数组 后缀自动机 Manacher 数据结构 并查集 分块 哈希 单调栈 单调队列 树状数组(可能依然不会) 线段树 zkw线段树 主席树 Treap Splay LCT 红黑树 fhq Treap 虚树 树套树 K-Dtree 图论 Dijkstra + Heap SPFA Floyd LCA 树剖 Kruskal k短路 差分约束 TopSort 强联通分量 双联通分量 2-SAT 二分图匹配 网络流 最大流最小割 拆点 费用流 上下界网络流 计算几何 三角剖分 凸包 扫描线 旋转卡壳 半平面交 杂 CDQ分治 莫队 模拟退火SA 随机增量 读优 树上启发式合并 离散化 复习计划 并查集 dfs bfs Dijkstra+Heap SPFA 手写qsort(用处不大?) 打表 二分板子 三分 二维前缀和&amp;差分 线性DP 背包 DFT/IDFT 杂项 Nim博弈学习报告补锅 多项式学习报告补锅]]></content>
      <tags>
        <tag>复习计划</tag>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019寒假成都摸鱼记]]></title>
    <url>%2F2019%2F02%2F01%2F2019%E5%AF%92%E5%81%87%E6%88%90%E9%83%BD%E6%91%B8%E9%B1%BC%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言还没放寒假的时候就知道要出去了，而且不用考生物，也是比较期待吧，于是肆意颓whk。这篇游记是Day7晚上在火车上写的，大多数印象比较清晰，知识点忘完了。 游记较长，大家可以跳着看。 Day -inf突然听说寒假要出去玩，还不用考生物，感觉很爽，也开始期待这场旅行（颓文化课）了。 Day -1上午考完英语后，就往校门口跑。没到门口就看到我爹了，但没看到潘老师。打电话才知道去考场找我们去了，假，连我在桌子上留的纸条都没看见。总归是到校门口了，就往火车站走。在赶时间的情况下，还在火车站对面的铁酒吃了一顿不错的午餐，心真是大。不过也没有很赶啦，着急地去了候车室后发现还早，就玩起了手机。候车的时候吃逼乎的安利下了这个神奇的计算器：Kalkyl（真叫这个，不是乱码） 居然可以画图像！虽然我严重怀疑这个${f(x)=x^x}$的图像画的有问题. 玩了会觉得没啥意思，然后就上车了。 在车上写了贪心的学习报告。本来准备写完后写线性DP的，但是鉴于贪心写了1000+（我太懒了），就没写了，开始颓CSGO。 打了一下午死斗，全是机器人一点都不好玩。手机也没有信号，又回忆起在重庆旅游时手机有信号没电的痛了…… 补了《Unnatural》的第一话，太好看了wocccccccccc！！可为什么硕鼠不能下载收费视频啊QAQ。 也没有全程颓啦，玩累了后把洛谷blog上的文章搬到了hexo上，顺便修改了一下补以前的锅。 关于《巴黎圣母院》，我忘了。 晚上没睡好QAQ，对面的小孩是真的吵。就晕晕地睡了大概四个小时。 这无所事事的一天就过去了。 Day 0早上6:00到站，第一感觉就是，火车站怎么跟襄阳站一样破，才知道这是老城区。（去的照片搞丢了，这是回来的时候照的） 出站后，找了好久才看到龟缩在角落的KFC，吃的也不算是丰盛。 实在是太困了…于是去了锦里的Starbucks，太早了人家都还没营业，好心的店主先把我们放进去了www。 待到了大概9:30的样子，回酒店了。感觉从酒店去锦里的时间比从锦里去酒店的时间要长的多。在酒店大堂看到了关老师(没上一节课的班主任)。 领了听课证、课表和笔记本后，就去吃午饭了。没吃火锅.难受.jpg。下午也没干啥，在酒店打了一下午LOL。 然后Day 0就结束了，依然无所事事。 Day 1起的早，在食堂吃了早饭后，得知教室居然在食堂里面？？？不过还不错啦。 最开始是hcy老师讲搜索，DFS我就没会过，讲了个框架，剩下大部分是讲例题。八皇后到是会，但八数码是啥啊……讲八数码，hcy就开始讲Hash，说到Hash，我就想到一个月前在机房用STL_SetA掉的字符串哈希，但是八数码好像并不能用Set做……一整节课，基本上强制在线。 搜索终于讲完了，接着讲的是贪心，这个我会。 国王游戏终于可以自己推了，高精依然不会（想）写。 贪心大概就是做题讲题做题讲题，知识性的东西并不多。 再然后就是分治与二分（没讲三分QAQ）。 思想还是清楚了，毕竟学过。然而在做题的时候发现自己打的好像是个假的二分板子： 12345while(l+1&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(ans&gt;=mid)mid=l; else mid=r;&#125; 然后自己的DEBUG套路好像也行不通了（增减”=“号与+1或-1）。 于是老老实实地就题论题打板子。 至于快速幂，讲的板子好像和我打的又不太一样还好我那个也能用。 晚上把部分题写了写，剩下了一些（懒得）难以实现的。 回到酒店后颓了几集《Unnatural》。 Day 1就结束了。 Day 2没吃早饭（真的吃不下） 早上去了没来什么人？？？（果然都吃早饭去了） 一整天都在讲数据结构。 二叉堆？_priority_queue_就好了！ 二叉搜索树？_set_就好了！ 改革春风吹满地，_STL_真争气。 然后就讲起了并查集。 板子还是比较熟的，不过老师没讲按秩合并，只讲了路径压缩。 这是按秩合并的板子: 12345678int fa[maxn],size[maxn];void init(int n)&#123;for(register int i=1;i&lt;=n;i++)&#123;fa[i]=i;size[i]=1;&#125;&#125;int find(int x)&#123;return fa[x]==x?x:find(fa[x]);&#125;void merge(int x,int y)&#123; int xx=find(x),yy=find(y); if(size[xx]&gt;size[yy])swap(xx,yy); fa[xx]=yy;size[yy]+=size[xx];&#125; 讲起了线段树： 我果然还是不会有灵魂（Lazy Tag ）的线段树QAQ。懂是懂了，但是怎么实现啊 在luogu找了题解学习，大概明白怎么实现了。 讲完lazy tag，又讲了一大堆玄学？ 那一刻，仿佛所有题都能套线段树A掉。线段树太棒了 树状数组离线了……学不来晚上写了一写题目，很多堆部分的练习以前都写过。 期望的RMQ和LCA都没有讲。 Day 2结束了。 Day 3考试日。 上午在讲数论，并没有慌得一批。 gcd有一个更加简短的实现了： 1int gcd(int a,int b)&#123;return b?gcd(b,a%b):a;&#125; lcm相对简单: 1int lcm(int a,int b)&#123;return a*b/gcd(a,b);&#125; 关于扩展欧几里得，以前打乘法逆元的板子时了解过，一直不会推，现在也会了。这里只给出代码： 123456789int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(!b)&#123; x=1;y=0; return a; &#125; int g=exgcd(b,a%b,y,x); y-=a/b*x; return g;&#125; 然后是筛法的预备知识：质数判定： 只需要枚举到${\sqrt n}​$就行了,但需要注意从2枚举。 1234567bool check(int n)&#123; if(n==1||n==0) return 0; for(register int i=2;i&lt;=sqrt(n);i++)&#123; if(!(n%i)) return 0;//一定要注意位运算符优先于算数运算符 &#125; return 1;&#125; 然后是埃氏筛（好久没打写挂了好几次）： 12345678for(register int i=1;i&lt;=maxn;i++)&#123; if(check(i)&amp;&amp;!vis[i])&#123; is[i]=1; for(register int j=i;j&lt;=maxn;j+=i)&#123; vis[i]=1; &#125; &#125; &#125; 质因数分解：不放在这了。 最后就是逆元了： 可以运用费马小定理： ${a^{p-1}}$ ≡ 1 (mod p),p为质数,a与p互质 （注意p为质数，不过noip如果要求逆元，p肯定是质数） 由此可得： a*${a^{p-2}}$ ≡ 1 (mod p)所以，当模数为质数p时，a的逆元等于${a^{p-2}}$‘ 当然也可以运用扩展欧几里得，这里不再赘述。 知识点就这些，也没写到什么题。下午就开始考试了。 这是题目： T1随便写（虽然考场上没写优化挂了60分） T2在考场上想了一个用set维护的骚操作，复杂度带log，应该能过，可惜最大值维护错了。 这是改后的代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;set&gt;#define max(a,b) a&gt;b?a:b#define maxn 100010using namespace std;set&lt;int&gt;a;set&lt;int&gt;::iterator it;int main()&#123; freopen("guinness.in","r",stdin); freopen("guinness.out","w",stdout); int m,x,n,t,cnt=1,ans,maxx=0; scanf("%d",&amp;m); for(register int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;x); a.insert(x); &#125; scanf("%d",&amp;t); for(register int i=1;i&lt;=t;i++)&#123; it=a.begin();ans=1; scanf("%d",&amp;n);cnt=0;int tmp[n+1]; for(register int j=1;j&lt;=n;j++)&#123; scanf("%d",&amp;x); tmp[++cnt]=x; bool getans = 0; for(it,ans;it!=a.end();it++,ans++)&#123; if(x&lt;*it)&#123; printf("%d ",ans); getans=1; break; &#125; &#125; if (!getans) printf("%d ",a.size()+1); &#125; printf("\n"); while(cnt) a.insert(tmp[cnt]),cnt--; &#125; fclose(stdin);fclose(stdout); return 0;&#125; T3可以爆搜，但是没时间（懒得写）了，就没写，直接交上去了。 所以成绩并不是很好。 _Expected:140_ _Score:40_ Day 4换老师了。 今天讲的是图论。 先讲了一大堆图的概念，学过了，所以在下面复习_Dijkstra+Heap_ 然后开始讲图的存储方式，前向星听了一下，剩下的学过，继续颓_Dijkstra+Heap_ 终于开始讲最短路了：果然开始就讲Dijkstra…没有堆优化太咸了!!! 于是继续颓_Dijkstra+Heap_… 讲完后开始讲可爱的SPFA了，标准版的最短路果然还是构造数据卡了SPFA。 挂个SPFA的工作图: 关于Bellman Ford，只是提了一下和SPFA很像，丢了一个blog链接，并没有细讲。 讲完单源，自然开始讲多源 多源自然讲了可爱的$O(n^3)$的Floyd 五行代码真是太好了： 12345for(register int k=1;k&lt;=n;k++) for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=n;j++) if(map[i][k]+map[k][j]&lt;map[i][j]) map[i][j]=map[i][k]+map[k][j]; 在做题的过程中学了一些奇巧淫技： 比如： 多源一汇最短路径？存个反图跑SPFA: 死掉的SPFA也可以判负环：（代码摘自这里） 12345678910111213141516171819202122232425262728bool spfa(int n) &#123; int u, v; while (!q.empty()) q.pop(); memset(vis, false, sizeof(vis)); memset(in, 0, sizeof(in)); fill(d, d + n, oo); d[0] = 0; vis[0] = true; q.push(0); while (!q.empty()) &#123; u = q.front(); vis[u] = false; for (int i = prev[u]; i != -1; i = edge[i].next) &#123; v = edge[i].v; if (d[u] + edge[i].t &lt; d[v]) &#123; d[v] = d[u] + edge[i].t; if (!vis[v]) &#123; in[v] ++; if (in[v] &gt; n) return true; vis[v] = true; q.push(v); &#125; &#125; &#125; vis[u] = false; q.pop(); &#125; return false;&#125; 最短路讲完后是最小生成树，一样只是提了一下Prim，重点是Kruskal：使用了并查集，也非常好理解：直接给出代码实现： 123456789101112131415int find(int x)&#123;return fa[x]==x?x:find(fa[x]);&#125;bool merge(int x,int y)&#123; int xx=find(x);int yy=find(y); if(xx!=yy)&#123; fa[xx]=yy; return 1; &#125; return 0;&#125;for(register int i=1;i&lt;=m;i++)&#123; if(merge(s[i].x,s[i].y))&#123; sum+=s[i].w;cnt++; if(cnt==n-1) break; &#125;&#125; 非常好理解，于是讲的很快。 然后是TopSort（拓扑排序）：相当于是寻找InDegree=0的点，push，然后删除。 也很好理解。代码实现：(行吧这是课件上的代码我没看懂) 123456789101112131415161718192021bool TopologicalSort(DirectGraph &amp;g,vector&lt;int&gt;&amp;in_degree)&#123; queue&lt;int&gt;qu; int cnt=0; for(auto ite=in_degree.begin();ite !=in_degree.end();++ite)&#123; if(*ite==0)&#123; qu.push(*ite); &#125; &#125; while(!qu.empty())&#123; int v=qu.front(); qu.pop(); printf("%d ",v); cnt++; for(const int &amp;i:g.adj.at(v))&#123; if(0==--in_degree[i])&#123; qu.push(i); &#125; &#125; &#125; return cnt&gt;=v;&#125; 最后讲了树上倍增求LCA（该来的总是会来） 知识听懂了，但是实现过程看的稀里糊涂的，几乎强制在线 就像中国RMB一样，每次都尝试最大的${2^i \leq n}$，总能凑出LCA位置，毕竟${2^0 =1}$嘛。 晚上写了个Dijkstra+Heap的A+B Problem（我太咸了） 回酒店依然补剧… Day 5讲DP，本来满怀期待的，后来发现好多题以前都写过… 唯一值得一提的是01背包的原理又理解了一遍，比以前掌握的好多了。 Day 5没啥好写的。 Day 6又是考试日。也换老师了。 上午讲的STL，也没啥好写的，会的以前都会，不会的比如全排列，无非感叹很有用，然后会用了，也没什么好说，（所以这玩意真方便）。 下午的考试： 解压后看T1，看了看数据范围，觉得60pts打表能出，很稳，就开了Excel，写T1 Expected 60 5分钟写了暴力挂在那打表，开始看T2。 T2感觉没啥思路，打暴力的时候把dfs忘了（果然我还是不会dfs）~写了${O(n^3)}$的存图，然后T1还没跑完，很慌，关了exe，把源程序的20改成了10打表，打开一看： …… 直接撸快速幂，100到手。 表变成了这个 那个tip还是我手画了一棵树后验证的 实在想不出来，一脑抽，就把T1交了…… 然后看到群里的： 然后…. …… 不得不滚回去打T2了。 暴力写挂了…… T3依然不知道在讲什么。 所以考试算是半凉凉吧…… _Expected 160_ _Score=100_ 莫名rk3。 Day 7上午讲了历年的一些题。 听懂了xkdyh的玄学解法，也会了货币系统老凯的疑惑 心心念念的天天爱跑步没讲 直到Day 7我才知道原来课表里面没有KMP 然后就结束了。 突然想到要滚回去上whk了，对这个地方还是有点不舍。 挂几张照片吧。 Day inf卧在学校里，终于补了这篇游记的锅，虽然干货不多，但是知识点会慢慢写总结。 做该做的，才对的起自己。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P3406 海底高铁 解题报告]]></title>
    <url>%2F2019%2F01%2F24%2F%E6%B5%B7%E5%BA%95%E9%AB%98%E9%93%81%2F</url>
    <content type="text"><![CDATA[题目链接:P3406 海底高铁题目分析:​ （第一眼以为是最短路） 这道题作为前缀和的练习挺不错的，因为它几乎不涉及其他算法。 ​ 首先根据题目中的信息进行数据读入：不开long long见祖宗（这题貌似不会） 123456789ll n,m,ans=0;//共N个城市,途经M个城市scanf("%lld%lld",&amp;n,&amp;m);ll p[m+1];//访问顺序ll t[n+1]=&#123;&#125;;//经过次数,一定要初始化！ll a[n+1],b[n+1],c[n+1],x,y;//a[i]纸质单程票,b[i]办卡后的优惠价,c[i]办卡工本费for(ll i=1;i&lt;=m;i++) scanf("%lld",&amp;p[i]);for(ll i=1;i&lt;=n-1;i++) scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); ​ 由于第i段铁路连接了城市i和城市i+1，所以任意两个相邻的站点购买同种车票有且仅有一种费用，也就是说，价格仅与在某相邻两站之间的通过次数有关。此时，我们就将问题转化为求在给定路线下，每相邻两个站点路段的经过次数. ​ 那么，在出发之前，我们可以将每两站之间路段的经过次数全部初始化为0，然后，对每次给定的始发站和终到站，将其视作给定区间的两个端点，对此区间进行区间增操作。 如何进行区间增呢？？？首先这是给定的四个站点 ​ 如果我们按照1-3,3-2,2-4,4-3的顺序访问，可以发现四个站点间的路径经过次数是这样的： 路径 1-2 2-3 3-4 次数 1 3 2 ​ 一般的思路是，对于每个区间，用一个for对其所经次数++，然而我们发现，太慢了。 ​ 于是我们想到了前缀和： 对于每一个区间，我们可以在其左端点加上区间增的权值，再在右端点+1的位置减去区间增的权值，最后对该区间进行求前缀和操作。这样，我们可以得到一样的结果。 回到题目中​ 恍然大悟，对于每组给定的区间端点，也可以使用同样的方法。更方便地，我们可以在对所有区间端点处理完毕后，在进行求前缀和操作： 12345678910111213141516171819202122 //由于给定的信息是端点（城市），但是要求的是区间（路段），所以循环次数应为城市数-1 for(ll i=1;i&lt;=m-1;i++)&#123; //对于端点的处理，要严格满足数学上的定义，小的在左端点，大的在右端点 //否则对于逆序信息，就相当于进行了区间减操作 if(p[i]&gt;p[i+1])&#123; x=p[i+1]; y=p[i]; &#125; else&#123; x=p[i]; y=p[i+1]; &#125; //上面的代码可以简写为: //x=min(p[i],p[i+1]); //y=max(p[i],p[i+1]); t[x]++;//左端点增 t[y]--;//右端点减 &#125;//求前缀和 for(ll i=1;i&lt;=n;i++)&#123; t[i]+=t[i-1]; &#125; ​ 最后，对于每一段路径，总价值加上该段路径费用的较小值。 12for(ll i=1;i&lt;=n-1;i++) ans+=min(a[i]*t[i],(b[i]*t[i]+c[i])); ​ 本题就解决啦！ 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define ll long long#define max(a,b) a&gt;b?a:b#define min(a,b) a&lt;b?a:busing namespace std;int main()&#123; ll n,m,ans=0; scanf("%lld%lld",&amp;n,&amp;m); ll p[m+1]; ll t[n+1]=&#123;&#125;; ll a[n+1],b[n+1],c[n+1],x,y; for(ll i=1;i&lt;=m;i++) scanf("%lld",&amp;p[i]); for(ll i=1;i&lt;=n-1;i++) scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); for(ll i=1;i&lt;=m-1;i++)&#123; if(p[i]&gt;p[i+1])&#123; x=p[i+1]; y=p[i]; &#125; else&#123; x=p[i]; y=p[i+1]; &#125; t[x]++; t[y]--; &#125; for(ll i=1;i&lt;=n;i++)&#123; t[i]+=t[i-1]; &#125; for(ll i=1;i&lt;=n-1;i++) ans+=min(a[i]*t[i],(b[i]*t[i]+c[i])); printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>前缀和</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心策略 学习报告]]></title>
    <url>%2F2019%2F01%2F24%2F%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[大胆贪心，（不用）小心证明。——阮行止 简介定义贪心算法，本质上来讲不是一种算法，而是一种策略。其基本思路是在题解满足局部最优解将导致全局最优解时，每一次决策考虑且仅考虑当前最优解。 举个例子就拿天朝RMB面额的设计来讲，仅举元这一单位，分别有1元，5元，10元，50元，100元五种面额。为什么要这样设计呢？在日常的生活中，我们买东西时就会发现，对于任意一个价格的商品，我们在购买时，要想花费最少张数的RMB，只需永远花费当前小于等于商品面额的货币。这就是一种贪心策略。 例子的证明我太菜了不会证。 使用条件题意方面在定义中就提到过，要想使用贪心策略，一定要在题解满足局部最优解导致全局最优解。对于简单的贪心，你看题面就知道这是个贪心，而有技巧的贪心则需要自己的猜测与证明。 关于局部最优解局部最优解，即在当前局面看来，不考虑后续状态的情况下，结果最优的解。即是当前问题的一个子问题的最优解。 贪心的证明贪心策略是需要证明的，至于严谨性就看个人对于答案的确信程度和rp。 常用的方法微扰法个人至今都不是很会的一种方法。就是先假设一种贪心策略，再对该策略的局面做出所有可能的扰动（如交换相邻的两个元素），然后讨论扰动后的局面是否会造成更优的局面，若是，则原贪心策略被推翻；若对于所有的扰动局面，都有原贪心策略优于微扰后的策略，那么贪心成立。 解集分析法先枚举出小规模内的局面，若对于该规模问题，所有的解均能由同一种贪心策略取得，那么考虑该策略，扩大问题规模（有点像迭代加深搜索），将该策略取得的解与枚举的解对比，若成立，则策略极有可能成立。注意这里的极有可能，有些毒瘤数据可能刚好违背该策略，所以这是一种不严谨的方法。 数学方法我们先看个典例： 排队打水问题有n个人排队到r个水龙头去打水，他们装满水桶的时间t1、t2………..tn为整数且各不相等，应如何安排他们的打水顺序才能使他们总共花费的时间最少？ 好像前面两种方法都行不通了？其实我没试过我没来看一个黑科技： 排序不等式不等式的证明百科上讲的很清楚了，我就把结论挂在这吧：$$\text{对于两个有序数组:$a_1\le a_2\le a_3\le …\le a_n$及$b_1\le b_2\le b_3\le …\le b_n$:}​$$ $$\sum\limits_{i=1}^na_ib_i\ge \sum\limits_{i=1}^na_ib_{j_i}\ge\sum\limits_{i=1}^na_ib_{n+1-i} $$ $${通俗来讲，就是顺序和\ge 乱序和\ge 逆序和}$$ 那么，上面的例子就很好解决了吧？ 总是规划打水时间最短者先打，再计算总打水时间，就可以得到最优的打水时间。 总结正如阮行止所说,“太贪心了是要栽跟头的。”，贪心策略固可解决一部分题，但是，如果时时刻刻想着贪心，DP也写贪心，终究是得不到高分的。做人也正是如此吧。]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1616 疯狂的采药 解题报告]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[题目链接:P1616 疯狂的采药题目分析：很明显的完全背包。首先，我们先把这道题转化为标准完全背包： 各种草药 物品 草药的价值 物品的价值 草药的采摘时间 物品的质量 总采摘时间 背包容量 ok,那么这道题就变成了板子题。 我们先来设计状态： 设$$\text{dp[i]为背包容量为i时，能放下的物品的最大价值}$$ $$\text{t[j]与p[j]分别存储第j个物品的质量和价值}$$ 然后进行状态转移： 对于容量为k的背包，第m个物品，我们考虑： 如果放这件物品，那么k容量背包的价值为dp[k-t[m]]+p[m] 如果不放，那么k容量背包的价值仍为原始的dp[k] 根据数组dp的定义，我们可以得到状态转移方程: $$\text{dp[k]=max(dp[k-t[m]]+p[m],dp[k])}$$ 同时，我们需要考虑该物品放入背包的先决条件： $$\text{k-t[m]}\ge\text{0}$$ 考虑每一件物品，并且综合上面的条件,我们得到了代码：1234567for(int i=1;i&lt;=T;i++)&#123; dp[i]=0; //初始化，可通过将数组开在主函数外面省略这一步 for(int j=1;j&lt;=n;j++)&#123; if(i-t[j]&gt;=0) dp[i]=max(dp[i],dp[i-t[j]]+p[j]) &#125; &#125; 问题所求的便是dp[T]。 Source Code1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::max;int main()&#123; int n,T; scanf("%d%d",&amp;T,&amp;n); int t[n+1],p[n+1],dp[T+1]; for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;t[i],&amp;p[i]); &#125; dp[0]=0; for(int i=1;i&lt;=T;i++)&#123; dp[i]=0; for(int j=1;j&lt;=n;j++)&#123; if(i-t[j]&gt;=0) dp[i]=max(dp[i],dp[i-t[j]]+p[j]) &#125; &#125; printf("%d",dp[T]); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小闹钟]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%B0%8F%E9%97%B9%E9%92%9F%2F</url>
    <content type="text"><![CDATA[简介你从来没有玩过的船新版本当前版本只支持倒计时(巨水 Source Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdlib&gt;#include&lt;windows.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int hour,second,minute; cout&lt;&lt;"输入格式\"时 分 秒\""&lt;&lt;endl; cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second; if(minute==60&amp;&amp;second&gt;0) &#123; cout&lt;&lt;"Input error!"&lt;&lt;endl; &#125; else &#123; if(minute&gt;60||second&gt;60) cout&lt;&lt;"Input error!"&lt;&lt;endl; else &#123; for(int i=3600*hour+60*minute+second;i&gt;0;Sleep(1000),i--) &#123; system("cls"); if((minute)&lt;0) &#123; hour-=1; minute=60; &#125; if((second-1)&lt;0) &#123; minute-=1; second=60; &#125; if(second&lt;10&amp;&amp;minute&lt;10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":0"&lt;&lt;minute&lt;&lt;":0"&lt;&lt;second&lt;&lt;endl; &#125; if(second&lt;10&amp;&amp;minute&gt;=10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":"&lt;&lt;minute&lt;&lt;":0"&lt;&lt;second&lt;&lt;endl; &#125; if(second&gt;=10&amp;&amp;minute&lt;10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":0"&lt;&lt;minute&lt;&lt;":"&lt;&lt;second&lt;&lt;endl; &#125; if(second&gt;=10&amp;&amp;minute&gt;=10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":"&lt;&lt;minute&lt;&lt;":"&lt;&lt;second&lt;&lt;endl; &#125; &#125; for(int i=10;i&gt;0;i--) &#123; cout&lt;&lt;"\a"&lt;&lt;endl; Sleep(1000); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
