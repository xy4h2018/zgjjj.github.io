<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[贪心策略 学习报告]]></title>
    <url>%2F2019%2F01%2F24%2F%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[大胆贪心，（不用）小心证明。——阮行止 简介定义贪心算法，本质上来讲不是一种算法，而是一种策略。其基本思路是在题解满足局部最优解将导致全局最优解时，每一次决策考虑且仅考虑当前最优解。 举个例子就拿天朝RMB面额的设计来讲，仅举元这一单位，分别有1元，5元，10元，50元，100元五种面额。为什么要这样设计呢？在日常的生活中，我们买东西时就会发现，对于任意一个价格的商品，我们在购买时，要想花费最少张数的RMB，只需永远花费当前小于等于商品面额的货币。这就是一种贪心策略。 例子的证明我太菜了不会证。 使用条件题意方面在定义中就提到过，要想使用贪心策略，一定要在题解满足局部最优解导致全局最优解。对于简单的贪心，你看题面就知道这是个贪心，而有技巧的贪心则需要自己的猜测与证明。 关于局部最优解局部最优解，即在当前局面看来，不考虑后续状态的情况下，结果最优的解。即是当前问题的一个子问题的最优解。 贪心的证明贪心策略是需要证明的，至于严谨性就看个人对于答案的确信程度和rp。 常用的方法微扰法个人至今都不是很会的一种方法。就是先假设一种贪心策略，再对该策略的局面做出所有可能的扰动（如交换相邻的两个元素），然后讨论扰动后的局面是否会造成更优的局面，若是，则原贪心策略被推翻；若对于所有的扰动局面，都有原贪心策略优于微扰后的策略，那么贪心成立。 解集分析法先枚举出小规模内的局面，若对于该规模问题，所有的解均能由同一种贪心策略取得，那么考虑该策略，扩大问题规模（有点像迭代加深搜索），将该策略取得的解与枚举的解对比，若成立，则策略极有可能成立。注意这里的极有可能，有些毒瘤数据可能刚好违背该策略，所以这是一种不严谨的方法。 数学方法我们先看个典例： 排队打水问题有n个人排队到r个水龙头去打水，他们装满水桶的时间t1、t2………..tn为整数且各不相等，应如何安排他们的打水顺序才能使他们总共花费的时间最少？ 好像前面两种方法都行不通了？其实我没试过我没来看一个黑科技： 排序不等式不等式的证明百科上讲的很清楚了，我就把结论挂在这吧：$$\text{对于两个有序数组:$a_1\le a_2\le a_3\le …\le a_n$及$b_1\le b_2\le b_3\le …\le b_n$:}​$$ $$\sum\limits_{i=1}^na_ib_i\ge \sum\limits_{i=1}^na_ib_{j_i}\ge\sum\limits_{i=1}^na_ib_{n+1-i} $$ $${通俗来讲，就是顺序和\ge 乱序和\ge 逆序和}$$ 那么，上面的例子就很好解决了吧？ 总是规划打水时间最短者先打，再计算总打水时间，就可以得到最优的打水时间。 总结正如阮行止所说,“太贪心了是要栽跟头的。”，贪心策略固可解决一部分题，但是，如果时时刻刻想着贪心，DP也写贪心，终究是得不到高分的。做人也正是如此吧。]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1616 疯狂的采药 解题报告]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[题目链接:P1616 疯狂的采药题目分析：很明显的完全背包。首先，我们先把这道题转化为标准完全背包： 各种草药 物品 草药的价值 物品的价值 草药的采摘时间 物品的质量 总采摘时间 背包容量 ok,那么这道题就变成了板子题。 我们先来设计状态： 设$$\text{dp[i]为背包容量为i时，能放下的物品的最大价值}$$ $$\text{t[j]与p[j]分别存储第j个物品的质量和价值}$$ 然后进行状态转移： 对于容量为k的背包，第m个物品，我们考虑： 如果放这件物品，那么k容量背包的价值为dp[k-t[m]]+p[m] 如果不放，那么k容量背包的价值仍为原始的dp[k] 根据数组dp的定义，我们可以得到状态转移方程: $$\text{dp[k]=max(dp[k-t[m]]+p[m],dp[k])}$$ 同时，我们需要考虑该物品放入背包的先决条件： $$\text{k-t[m]}\ge\text{0}$$ 考虑每一件物品，并且综合上面的条件,我们得到了代码：1234567for(int i=1;i&lt;=T;i++)&#123; dp[i]=0; //初始化，可通过将数组开在主函数外面省略这一步 for(int j=1;j&lt;=n;j++)&#123; if(i-t[j]&gt;=0) dp[i]=max(dp[i],dp[i-t[j]]+p[j]) &#125; &#125; 问题所求的便是dp[T]。 Source Code1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::max;int main()&#123; int n,T; scanf("%d%d",&amp;T,&amp;n); int t[n+1],p[n+1],dp[T+1]; for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;t[i],&amp;p[i]); &#125; dp[0]=0; for(int i=1;i&lt;=T;i++)&#123; dp[i]=0; for(int j=1;j&lt;=n;j++)&#123; if(i-t[j]&gt;=0) dp[i]=max(dp[i],dp[i-t[j]]+p[j]) &#125; &#125; printf("%d",dp[T]); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小闹钟]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%B0%8F%E9%97%B9%E9%92%9F%2F</url>
    <content type="text"><![CDATA[简介你从来没有玩过的船新版本当前版本只支持倒计时(巨水 Source Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdlib&gt;#include&lt;windows.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int hour,second,minute; cout&lt;&lt;"输入格式\"时 分 秒\""&lt;&lt;endl; cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second; if(minute==60&amp;&amp;second&gt;0) &#123; cout&lt;&lt;"Input error!"&lt;&lt;endl; &#125; else &#123; if(minute&gt;60||second&gt;60) cout&lt;&lt;"Input error!"&lt;&lt;endl; else &#123; for(int i=3600*hour+60*minute+second;i&gt;0;Sleep(1000),i--) &#123; system("cls"); if((minute)&lt;0) &#123; hour-=1; minute=60; &#125; if((second-1)&lt;0) &#123; minute-=1; second=60; &#125; if(second&lt;10&amp;&amp;minute&lt;10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":0"&lt;&lt;minute&lt;&lt;":0"&lt;&lt;second&lt;&lt;endl; &#125; if(second&lt;10&amp;&amp;minute&gt;=10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":"&lt;&lt;minute&lt;&lt;":0"&lt;&lt;second&lt;&lt;endl; &#125; if(second&gt;=10&amp;&amp;minute&lt;10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":0"&lt;&lt;minute&lt;&lt;":"&lt;&lt;second&lt;&lt;endl; &#125; if(second&gt;=10&amp;&amp;minute&gt;=10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":"&lt;&lt;minute&lt;&lt;":"&lt;&lt;second&lt;&lt;endl; &#125; &#125; for(int i=10;i&gt;0;i--) &#123; cout&lt;&lt;"\a"&lt;&lt;endl; Sleep(1000); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
