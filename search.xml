<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Luogu P3406 海底高铁 解题报告]]></title>
    <url>%2F2019%2F01%2F24%2F%E6%B5%B7%E5%BA%95%E9%AB%98%E9%93%81%2F</url>
    <content type="text"><![CDATA[题目链接:P3406 海底高铁题目分析:​ （第一眼以为是最短路） 这道题作为前缀和的练习挺不错的，因为它几乎不涉及其他算法。 ​ 首先根据题目中的信息进行数据读入：不开long long见祖宗（这题貌似不会） 123456789ll n,m,ans=0;//共N个城市,途经M个城市scanf("%lld%lld",&amp;n,&amp;m);ll p[m+1];//访问顺序ll t[n+1]=&#123;&#125;;//经过次数,一定要初始化！ll a[n+1],b[n+1],c[n+1],x,y;//a[i]纸质单程票,b[i]办卡后的优惠价,c[i]办卡工本费for(ll i=1;i&lt;=m;i++) scanf("%lld",&amp;p[i]);for(ll i=1;i&lt;=n-1;i++) scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); ​ 由于第i段铁路连接了城市i和城市i+1，所以任意两个相邻的站点购买同种车票有且仅有一种费用，也就是说，价格仅与在某相邻两站之间的通过次数有关。此时，我们就将问题转化为求在给定路线下，每相邻两个站点路段的经过次数. ​ 那么，在出发之前，我们可以将每两站之间路段的经过次数全部初始化为0，然后，对每次给定的始发站和终到站，将其视作给定区间的两个端点，对此区间进行区间增操作。 #### 如何进行区间增呢？？？ 首先这是给定的四个站点 ​ 如果我们按照1-3,3-2,2-4,4-3的顺序访问，可以发现四个站点间的路径经过次数是这样的： 路径 1-2 2-3 3-4 次数 1 3 2 ​ 一般的思路是，对于每个区间，用一个for对其所经次数++，然而我们发现，太慢了。 ​ 于是我们想到了前缀和： 对于每一个区间，我们可以在其左端点加上区间增的权值，再在右端点+1的位置减去区间增的权值，最后对该区间进行求前缀和操作。这样，我们可以得到一样的结果。 #### 回到题目中 ​ 恍然大悟，对于每组给定的区间端点，也可以使用同样的方法。更方便地，我们可以在对所有区间端点处理完毕后，在进行求前缀和操作： 12345678910111213141516171819202122 //由于给定的信息是端点（城市），但是要求的是区间（路段），所以循环次数应为城市数-1 for(ll i=1;i&lt;=m-1;i++)&#123; //对于端点的处理，要严格满足数学上的定义，小的在左端点，大的在右端点 //否则对于逆序信息，就相当于进行了区间减操作 if(p[i]&gt;p[i+1])&#123; x=p[i+1]; y=p[i]; &#125; else&#123; x=p[i]; y=p[i+1]; &#125; //上面的代码可以简写为: //x=min(p[i],p[i+1]); //y=max(p[i],p[i+1]); t[x]++;//左端点增 t[y]--;//右端点减 &#125;//求前缀和 for(ll i=1;i&lt;=n;i++)&#123; t[i]+=t[i-1]; &#125; ​ 最后，对于每一段路径，总价值加上该段路劲费用的较小值。 12for(ll i=1;i&lt;=n-1;i++) ans+=min(a[i]*t[i],(b[i]*t[i]+c[i])); ​ 本题就解决啦！ 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define ll long long#define max(a,b) a&gt;b?a:b#define min(a,b) a&lt;b?a:busing namespace std;int main()&#123; ll n,m,ans=0; scanf("%lld%lld",&amp;n,&amp;m); ll p[m+1]; ll t[n+1]=&#123;&#125;; ll a[n+1],b[n+1],c[n+1],x,y; for(ll i=1;i&lt;=m;i++) scanf("%lld",&amp;p[i]); for(ll i=1;i&lt;=n-1;i++) scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); for(ll i=1;i&lt;=m-1;i++)&#123; if(p[i]&gt;p[i+1])&#123; x=p[i+1]; y=p[i]; &#125; else&#123; x=p[i]; y=p[i+1]; &#125; t[x]++; t[y]--; &#125; for(ll i=1;i&lt;=n;i++)&#123; t[i]+=t[i-1]; &#125; for(ll i=1;i&lt;=n-1;i++) ans+=min(a[i]*t[i],(b[i]*t[i]+c[i])); printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>差分</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心策略 学习报告]]></title>
    <url>%2F2019%2F01%2F24%2F%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5-%E5%AD%A6%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[大胆贪心，（不用）小心证明。——阮行止 简介定义贪心算法，本质上来讲不是一种算法，而是一种策略。其基本思路是在题解满足局部最优解将导致全局最优解时，每一次决策考虑且仅考虑当前最优解。 举个例子就拿天朝RMB面额的设计来讲，仅举元这一单位，分别有1元，5元，10元，50元，100元五种面额。为什么要这样设计呢？在日常的生活中，我们买东西时就会发现，对于任意一个价格的商品，我们在购买时，要想花费最少张数的RMB，只需永远花费当前小于等于商品面额的货币。这就是一种贪心策略。 例子的证明我太菜了不会证。 使用条件题意方面在定义中就提到过，要想使用贪心策略，一定要在题解满足局部最优解导致全局最优解。对于简单的贪心，你看题面就知道这是个贪心，而有技巧的贪心则需要自己的猜测与证明。 关于局部最优解局部最优解，即在当前局面看来，不考虑后续状态的情况下，结果最优的解。即是当前问题的一个子问题的最优解。 贪心的证明贪心策略是需要证明的，至于严谨性就看个人对于答案的确信程度和rp。 常用的方法微扰法个人至今都不是很会的一种方法。就是先假设一种贪心策略，再对该策略的局面做出所有可能的扰动（如交换相邻的两个元素），然后讨论扰动后的局面是否会造成更优的局面，若是，则原贪心策略被推翻；若对于所有的扰动局面，都有原贪心策略优于微扰后的策略，那么贪心成立。 解集分析法先枚举出小规模内的局面，若对于该规模问题，所有的解均能由同一种贪心策略取得，那么考虑该策略，扩大问题规模（有点像迭代加深搜索），将该策略取得的解与枚举的解对比，若成立，则策略极有可能成立。注意这里的极有可能，有些毒瘤数据可能刚好违背该策略，所以这是一种不严谨的方法。 数学方法我们先看个典例： 排队打水问题有n个人排队到r个水龙头去打水，他们装满水桶的时间t1、t2………..tn为整数且各不相等，应如何安排他们的打水顺序才能使他们总共花费的时间最少？ 好像前面两种方法都行不通了？其实我没试过我没来看一个黑科技： 排序不等式不等式的证明百科上讲的很清楚了，我就把结论挂在这吧：$$\text{对于两个有序数组:$a_1\le a_2\le a_3\le …\le a_n$及$b_1\le b_2\le b_3\le …\le b_n$:}​$$ $$\sum\limits_{i=1}^na_ib_i\ge \sum\limits_{i=1}^na_ib_{j_i}\ge\sum\limits_{i=1}^na_ib_{n+1-i} $$ $${通俗来讲，就是顺序和\ge 乱序和\ge 逆序和}$$ 那么，上面的例子就很好解决了吧？ 总是规划打水时间最短者先打，再计算总打水时间，就可以得到最优的打水时间。 总结正如阮行止所说,“太贪心了是要栽跟头的。”，贪心策略固可解决一部分题，但是，如果时时刻刻想着贪心，DP也写贪心，终究是得不到高分的。做人也正是如此吧。]]></content>
      <tags>
        <tag>学习报告</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P1616 疯狂的采药 解题报告]]></title>
    <url>%2F2019%2F01%2F19%2F%E7%96%AF%E7%8B%82%E7%9A%84%E9%87%87%E8%8D%AF%2F</url>
    <content type="text"><![CDATA[题目链接:P1616 疯狂的采药题目分析：很明显的完全背包。首先，我们先把这道题转化为标准完全背包： 各种草药 物品 草药的价值 物品的价值 草药的采摘时间 物品的质量 总采摘时间 背包容量 ok,那么这道题就变成了板子题。 我们先来设计状态： 设$$\text{dp[i]为背包容量为i时，能放下的物品的最大价值}$$ $$\text{t[j]与p[j]分别存储第j个物品的质量和价值}$$ 然后进行状态转移： 对于容量为k的背包，第m个物品，我们考虑： 如果放这件物品，那么k容量背包的价值为dp[k-t[m]]+p[m] 如果不放，那么k容量背包的价值仍为原始的dp[k] 根据数组dp的定义，我们可以得到状态转移方程: $$\text{dp[k]=max(dp[k-t[m]]+p[m],dp[k])}$$ 同时，我们需要考虑该物品放入背包的先决条件： $$\text{k-t[m]}\ge\text{0}$$ 考虑每一件物品，并且综合上面的条件,我们得到了代码：1234567for(int i=1;i&lt;=T;i++)&#123; dp[i]=0; //初始化，可通过将数组开在主函数外面省略这一步 for(int j=1;j&lt;=n;j++)&#123; if(i-t[j]&gt;=0) dp[i]=max(dp[i],dp[i-t[j]]+p[j]) &#125; &#125; 问题所求的便是dp[T]。 Source Code1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::max;int main()&#123; int n,T; scanf("%d%d",&amp;T,&amp;n); int t[n+1],p[n+1],dp[T+1]; for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;t[i],&amp;p[i]); &#125; dp[0]=0; for(int i=1;i&lt;=T;i++)&#123; dp[i]=0; for(int j=1;j&lt;=n;j++)&#123; if(i-t[j]&gt;=0) dp[i]=max(dp[i],dp[i-t[j]]+p[j]) &#125; &#125; printf("%d",dp[T]); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小闹钟]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%B0%8F%E9%97%B9%E9%92%9F%2F</url>
    <content type="text"><![CDATA[简介你从来没有玩过的船新版本当前版本只支持倒计时(巨水 Source Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdlib&gt;#include&lt;windows.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int hour,second,minute; cout&lt;&lt;"输入格式\"时 分 秒\""&lt;&lt;endl; cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second; if(minute==60&amp;&amp;second&gt;0) &#123; cout&lt;&lt;"Input error!"&lt;&lt;endl; &#125; else &#123; if(minute&gt;60||second&gt;60) cout&lt;&lt;"Input error!"&lt;&lt;endl; else &#123; for(int i=3600*hour+60*minute+second;i&gt;0;Sleep(1000),i--) &#123; system("cls"); if((minute)&lt;0) &#123; hour-=1; minute=60; &#125; if((second-1)&lt;0) &#123; minute-=1; second=60; &#125; if(second&lt;10&amp;&amp;minute&lt;10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":0"&lt;&lt;minute&lt;&lt;":0"&lt;&lt;second&lt;&lt;endl; &#125; if(second&lt;10&amp;&amp;minute&gt;=10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":"&lt;&lt;minute&lt;&lt;":0"&lt;&lt;second&lt;&lt;endl; &#125; if(second&gt;=10&amp;&amp;minute&lt;10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":0"&lt;&lt;minute&lt;&lt;":"&lt;&lt;second&lt;&lt;endl; &#125; if(second&gt;=10&amp;&amp;minute&gt;=10) &#123; second--; cout&lt;&lt;hour&lt;&lt;":"&lt;&lt;minute&lt;&lt;":"&lt;&lt;second&lt;&lt;endl; &#125; &#125; for(int i=10;i&gt;0;i--) &#123; cout&lt;&lt;"\a"&lt;&lt;endl; Sleep(1000); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
